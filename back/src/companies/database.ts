/**
 * PRISMA HELPER FUNCTIONS
 */

import prisma from "../prisma";
import { User, Prisma, Company } from "@prisma/client";
import {
  CompanyNotFound,
  TraderReceiptNotFound,
  BrokerReceiptNotFound,
  TransporterReceiptNotFound,
  VhuAgrementNotFound,
  WorkerCertificationNotFound
} from "./errors";
import { CompanyMember } from "../generated/graphql/types";
import { UserInputError } from "apollo-server-express";
import { AppDataloaders } from "../types";

/**
 * Retrieves a company by any unique identifier or throw a CompanyNotFound error
 */
export async function getCompanyOrCompanyNotFound({
  id,
  orgId,
  siret,
  vatNumber
}: Prisma.CompanyWhereUniqueInput) {
  if (!id && !siret && !orgId) {
    throw new UserInputError(
      "You should specify an id or a siret or a VAT number"
    );
  }
  let where: Prisma.CompanyWhereUniqueInput;
  if (id) {
    where = { id };
  } else if (siret) {
    where = { siret };
  } else if (vatNumber) {
    where = { vatNumber };
  } else if (orgId) {
    where = { orgId };
  }
  const company = await prisma.company.findUnique({
    where
  });
  if (company == null) {
    throw new CompanyNotFound();
  }
  return company;
}

/**
 * Returns the ICPE associated with this company if any
 * or null otherwise
 * The table installation is generated by the `etl`
 * container where we are consolidating data
 * (join and fuzzy join) from s3ic, irep, gerep
 * and sirene to associate a siret with an ICPE
 * @param siret
 */
export function getInstallation(siret: string) {
  return prisma.installation
    .findFirst({
      where: {
        OR: [
          { s3icNumeroSiret: siret },
          { irepNumeroSiret: siret },
          { gerepNumeroSiret: siret },
          { sireneNumeroSiret: siret }
        ]
      }
    })
    .then(installation => {
      return installation ?? null;
    });
}

/**
 * Returns list of rubriques of an ICPE
 * @param codeS3ic
 */
export function getRubriques(codeS3ic: string) {
  if (codeS3ic) {
    return prisma.rubrique.findMany({ where: { codeS3ic } });
  }
  return Promise.resolve([]);
}

/**
 * Returns list of GEREP declarations of an ICPE
 * @param codeS3ic
 */
export function getDeclarations(codeS3ic: string) {
  if (codeS3ic) {
    return prisma.declaration.findMany({ where: { codeS3ic } });
  }
  return Promise.resolve([]);
}

/**
 * Returns the role (ADMIN or MEMBER) of a user
 * in a company.
 * Returns null if the user is not a member of the company.
 * There should be only one association between a user
 * and a company, so we return the first one
 * @param userId
 * @param orgId
 */
export async function getUserRole(userId: string, orgId: string) {
  const associations = await prisma.company
    .findUnique({ where: { orgId } })
    .companyAssociations({ where: { userId } });

  if (associations.length > 0) {
    return associations[0].role;
  }
  return null;
}

/**
 * Returns true if user belongs to company with either
 * MEMBER or ADMIN role, false otherwise
 * @param user
 */
export async function isCompanyMember(user: User, company: Company) {
  const count = await prisma.companyAssociation.count({
    where: {
      userId: user.id,
      companyId: company.id
    }
  });

  return count >= 1;
}

/**
 * Concat active company users and invited company users
 * @param orgId
 */
export async function getCompanyUsers(
  orgId: string,
  dataloaders: AppDataloaders
): Promise<CompanyMember[]> {
  const activeUsers = await getCompanyActiveUsers(orgId);
  const invitedUsers = await getCompanyInvitedUsers(orgId, dataloaders);

  return [...activeUsers, ...invitedUsers];
}

/**
 * Returns company members that already have an account in TD
 * @param siret
 */
export function getCompanyActiveUsers(orgId: string): Promise<CompanyMember[]> {
  return prisma.company
    .findUnique({ where: { orgId } })
    .companyAssociations({ include: { user: true } })
    .then(associations =>
      associations.map(a => {
        return {
          ...a.user,
          role: a.role,
          isPendingInvitation: false
        };
      })
    );
}

/**
 * Returns users who have been invited to join the company
 * but whose account haven't been created yet
 * @param siret
 */
export async function getCompanyInvitedUsers(
  orgId: string,
  dataloaders: AppDataloaders
): Promise<CompanyMember[]> {
  const hashes = await dataloaders.activeUserAccountHashesBySiret.load(orgId);
  return hashes.map(h => {
    return {
      id: h.id,
      name: "InvitÃ©",
      email: h.email,
      role: h.role,
      isActive: false,
      isPendingInvitation: true
    };
  });
}

/**
 * Returns active company members who are admin
 * of the company
 * @param siret
 */
export async function getCompanyAdminUsers(orgId: string) {
  const users = await getCompanyActiveUsers(orgId);
  return users.filter(c => c.role === "ADMIN");
}

/**
 * Get all the admins from companies, by companyIds
 */
export async function getActiveAdminsByCompanyIds(
  companyIds: string[]
): Promise<Record<string, User[]>> {
  const users = await prisma.companyAssociation
    .findMany({
      where: {
        companyId: { in: companyIds },
        role: "ADMIN",
        user: { isActive: true }
      },
      include: { user: true }
    })
    .then(associations =>
      associations.map(a => {
        return {
          ...a.user,
          companyId: a.companyId
        };
      })
    );

  const res: Record<string, User[]> = {};

  users.forEach(user => {
    if (res[user.companyId]) res[user.companyId].push(user);
    else res[user.companyId] = [user];
  });

  return res;
}

/**
 * Get all the companies and admins from companies, by companyOrgIds
 * Will return an object like:
 * {
 *   companies: { [orgId]: company},
 *   admins: { [ordId]: user[] }
 * }
 */
export const getCompaniesAndActiveAdminsByCompanyOrgIds = async (
  orgIds: string[]
): Promise<{
  companies: Record<string, Company>;
  admins: Record<string, User[]>;
}> => {
  const companiesAndAdmins = await prisma.companyAssociation
    .findMany({
      where: {
        company: { orgId: { in: orgIds } },
        role: "ADMIN",
        user: { isActive: true }
      },
      include: { user: true, company: true }
    })
    .then(associations =>
      associations.map(a => {
        return {
          admin: a.user,
          company: a.company
        };
      })
    );

  const companiesByOrgId: Record<string, Company> = {};
  const adminsByOrgId: Record<string, User[]> = {};

  companiesAndAdmins.forEach(companyAndAdmin => {
    companiesByOrgId[companyAndAdmin.company.orgId] = companyAndAdmin.company;

    if (adminsByOrgId[companyAndAdmin.company.orgId]) {
      adminsByOrgId[companyAndAdmin.company.orgId].push(companyAndAdmin.admin);
    } else {
      adminsByOrgId[companyAndAdmin.company.orgId] = [companyAndAdmin.admin];
    }
  });

  return { companies: companiesByOrgId, admins: adminsByOrgId };
};

export async function getTraderReceiptOrNotFound({
  id
}: Prisma.TraderReceiptWhereUniqueInput) {
  const receipt = await prisma.traderReceipt.findUnique({ where: { id } });
  if (receipt == null) {
    throw new TraderReceiptNotFound();
  }
  return receipt;
}

export async function getBrokerReceiptOrNotFound({
  id
}: Prisma.BrokerReceiptWhereUniqueInput) {
  const receipt = await prisma.brokerReceipt.findUnique({ where: { id } });
  if (receipt == null) {
    throw new BrokerReceiptNotFound();
  }
  return receipt;
}

export async function getTransporterReceiptOrNotFound({
  id
}: Prisma.TransporterReceiptWhereUniqueInput) {
  const receipt = await prisma.transporterReceipt.findUnique({ where: { id } });
  if (receipt == null) {
    throw new TransporterReceiptNotFound();
  }
  return receipt;
}

export async function getVhuAgrementOrNotFound({
  id
}: Prisma.VhuAgrementWhereUniqueInput) {
  const agrement = await prisma.vhuAgrement.findUnique({ where: { id } });
  if (agrement == null) {
    throw new VhuAgrementNotFound();
  }
  return agrement;
}

export async function getWorkerCertificationOrNotFound({
  id
}: Prisma.WorkerCertificationWhereUniqueInput) {
  const agrement = await prisma.workerCertification.findUnique({
    where: { id }
  });
  if (agrement == null) {
    throw new WorkerCertificationNotFound();
  }
  return agrement;
}

export function convertUrls<T extends Partial<Company>>(
  company: T
): T & { ecoOrganismeAgreements: URL[]; signatureAutomations: [] } {
  if (!company) {
    return null;
  }

  return {
    ...company,
    ...(company?.ecoOrganismeAgreements && {
      ecoOrganismeAgreements: company.ecoOrganismeAgreements.map(
        a => new URL(a)
      )
    }),
    signatureAutomations: []
  };
}
