import {
  CompanyWhereUniqueInput,
  prisma,
  User,
  UserRole
} from "../generated/prisma-client";
import { CompanyNotFound } from "./errors";
import { CompanyMember } from "../generated/graphql/types";

// PRISMA HELPER FUNCTIONS

/**
 * Retrieves a company by siret or or throw a CompanyNotFound error
 */
export async function getCompanyOrCompanyNotFound({
  id,
  siret
}: CompanyWhereUniqueInput) {
  if (!id && !siret) {
    throw new Error("You should specify an id or a siret");
  }
  const company = await prisma.company(id ? { id } : { siret });
  if (company == null) {
    throw new CompanyNotFound();
  }
  return company;
}

/**
 * Returns the ICPE associated with this company if any
 * or null otherwise
 * The table installation is generated by the `etl`
 * container where we are consolidating data
 * (join and fuzzy join) from s3ic, irep, gerep
 * and sirene to associate a siret with an ICPE
 * @param siret
 */
export function getInstallation(siret: string) {
  return prisma
    .installations({
      where: {
        OR: [
          { s3icNumeroSiret: siret },
          { irepNumeroSiret: siret },
          { gerepNumeroSiret: siret },
          { sireneNumeroSiret: siret }
        ]
      }
    })
    .then(installations => {
      // return first installation if several match
      return installations ? installations[0] : null;
    });
}

/**
 * Returns list of rubriques of an ICPE
 * @param codeS3ic
 */
export function getRubriques(codeS3ic: string) {
  if (codeS3ic) {
    return prisma.rubriques({ where: { codeS3ic } });
  }
  return Promise.resolve([]);
}

/**
 * Returns list of GEREP declarations of an ICPE
 * @param codeS3ic
 */
export function getDeclarations(codeS3ic: string) {
  if (codeS3ic) {
    return prisma.declarations({ where: { codeS3ic } });
  }
  return Promise.resolve([]);
}

/**
 * Returns the role (ADMIN or MEMBER) of a user
 * in a company.
 * Returns null if the user is not a member of the company.
 * There should be only one association between a user
 * and a company, so we return the first one
 * @param userId
 * @param siret
 */
export async function getUserRole(userId: string, siret: string) {
  const associations = await prisma.companyAssociations({
    where: { user: { id: userId }, company: { siret } }
  });
  if (associations.length > 0) {
    return associations[0].role;
  }
  return null;
}

/**
 * Concat active company users and invited company users
 * @param siret
 */
export async function getCompanyUsers(siret: string): Promise<CompanyMember[]> {
  const activeUsers = await getCompanyActiveUsers(siret);
  const invitedUsers = await getCompanyInvitedUsers(siret);

  return [...activeUsers, ...invitedUsers];
}

const companyMemberFragment = `
fragment CompanyMember on CompanyAssociation {
  role,
  user {
    id
    isActive
    name
    email
    phone
  }
}
`;

type CompanyMemberFragment = Pick<User, "id" | "email" | "name" | "isActive">;

/**
 * Returns company members that already have an account in TD
 * @param siret
 */
export function getCompanyActiveUsers(siret: string): Promise<CompanyMember[]> {
  return prisma
    .companyAssociations({ where: { company: { siret } } })
    .$fragment<{ user: CompanyMemberFragment; role: UserRole }[]>(
      companyMemberFragment
    )
    .then(associations =>
      associations.map(a => {
        return {
          ...a.user,
          role: a.role,
          isPendingInvitation: false
        };
      })
    );
}

/**
 * Returns users who have been invited to join the company
 * but whose account haven't been created yet
 * @param siret
 */
export async function getCompanyInvitedUsers(
  siret: string
): Promise<CompanyMember[]> {
  const hashes = await prisma.userAccountHashes({
    where: { companySiret: siret }
  });
  return hashes.map(h => {
    return {
      id: h.id,
      name: "InvitÃ©",
      email: h.email,
      role: h.role,
      isActive: false,
      isPendingInvitation: true
    };
  });
}

/**
 * Returns active company members who are admin
 * of the company
 * @param siret
 */
export async function getCompanyAdminUsers(siret: string) {
  const users = await getCompanyActiveUsers(siret);
  return users.filter(c => c.role === "ADMIN");
}
