scalar DateTime
scalar JSON

type Query {
  """
  Renvoie un BSD, sélectionné par ID
  """
  form(id: ID): Form
  """
  Renvoie les BSDs de la compagnie sélectionnée (la première par défaut)
  Par défaut, renvoie les BSDs dont on est producteur ou destinataire.
  On peut également demander les bordereaux pour lesquels on est transporteur
  """
  forms(siret: String, type: FormType = ACTOR): [Form]
  stats: [CompanyStat]
  """
  Renvoie des BSD candidats à un regroupement dans une annexe 2
  `siret`: Siret d'une des entreprises que j'administre
  `wasteCode`: Code déchet pour affiner la recherche, optionnel
  """
  appendixForms(siret: String!, wasteCode: String): [Form]

  """
  Renvoie un token pour télécharger un pdf de bordereau
  Ce token doit être transmis à la route /download pour obtenir le fichier.
  Il est valable 10 secondes
  """
  formPdf(id: ID): FileDownload
  formsRegister(
    sirets: [String]
    exportType: FormsRegisterExportType
  ): FileDownload

  
"""
Renvoie les changements de statut des bordereaux de l'entreprise sélectionnée. 
La liste est paginée par pages de 100 items, ordonnée par date décroissante (champ `created`)
Seuls les changements de statuts disposant d'un champ `created` non nul sont retournés
  
Filtres:

  `siret`: Siret d'une des entreprises que j'administre, optionnel

  `createdAfter`: date formatée après laquelle les changements de statut doivent être retournés (YYYY-MM-DD), optionnel

  `createdBefore`: date formatée avant laquelle les changements de statut doivent être retournés (YYYY-MM-DD), optionnel
  
  `formId`: id d'un bordereau, optionnel
  
Pagination:

  `cursorAfter`: cursor après lequel les changements de statut doivent être retournés, optionnel

  `cursorBefore`: cursor avant lequel les changements de statut doivent être retournés, optionnel
 
  """
  formsLifeCycle(siret: String, loggedBefore: String, loggedAfter: String, cursorAfter:String, cursorBefore:String, formId: ID):formsLifeCycleData

}


type Mutation {
  """
  Sauvegarde un BSD (création ou modification, si `FormInput` contient un ID)
  """
  saveForm(formInput: FormInput!): Form
  """
  Supprime un BSD
  """
  deleteForm(id: ID!): Form
  """
  Duplique un BSD
  """
  duplicateForm(id: ID!): Form

  """
  Scelle un BSD
  """
  markAsSealed(id: ID): Form
  """
  Valide l'envoi d'un BSD
  """
  markAsSent(id: ID, sentInfo: SentFormInput!): Form
  """
  Valide la réception d'un BSD
  """
  markAsReceived(id: ID, receivedInfo: ReceivedFormInput!): Form
  """
  Valide le traitement d'un BSD
  """
  markAsProcessed(id: ID, processedInfo: ProcessedFormInput!): Form

  """
  Valide la prise en charge par le transporteur, et peut valider l'envoi
  """
  signedByTransporter(
    id: ID!
    signingInfo: TransporterSignatureFormInput!
  ): Form
}

type Subscription {
  forms(token: String!): FormSubscription
}

type FormSubscription {
  mutation: String
  node: Form
  updatedFields: [String]
  previousValues: Form
}

enum FormStatus {
  DRAFT
  SEALED
  SENT
  RECEIVED
  PROCESSED
  AWAITING_GROUP
  GROUPED
  NO_TRACEABILITY
  REFUSED
}

"""
On peut récupérer les BSD par type:
- ACTOR: on est acteur du BSD, c'est à dire émetteur ou destinataire (cas par défaut)
- TRANSPORTER: on est uniquement transporteur du déchet
"""
enum FormType {
  ACTOR
  TRANSPORTER
}

"""
Représente un BSD
"""
type Form {
  id: ID
  readableId: String
  customId: String

  emitter: Emitter
  recipient: Recipient
  transporter: Transporter
  wasteDetails: WasteDetails
  trader: Trader

  createdAt: DateTime
  updatedAt: DateTime

  ownerId: Int
  status: FormStatus

  signedByTransporter: Boolean

  sentAt: DateTime
  sentBy: String

  wasteAcceptationStatus: String
  wasteRefusalReason: String
  receivedBy: String
  receivedAt: DateTime
  quantityReceived: Float

  processingOperationDone: String
  processingOperationDescription: String
  processedBy: String
  processedAt: DateTime
  noTraceability: Boolean
  nextDestination: NextDestination

  appendix2Forms: [Form]
}

type FormCompany {
  name: String
  siret: String
  address: String
  contact: String
  phone: String
  mail: String
}

enum EmitterType {
  PRODUCER
  OTHER
  APPENDIX1
  APPENDIX2
}

type Emitter {
  type: EmitterType
  pickupSite: String

  company: FormCompany
}

type Recipient {
  cap: String
  processingOperation: String

  company: FormCompany
}

type Transporter {
  company: FormCompany

  isExemptedOfReceipt: Boolean

  receipt: String
  department: String
  validityLimit: DateTime
  numberPlate: String
}

type NextDestination {
  processingOperation: String
  company: FormCompany
}

enum QuantityType {
  REAL
  ESTIMATED
}

enum Packagings {
  FUT
  GRV
  CITERNE
  BENNE
  AUTRE
}

enum Consistence {
  SOLID
  LIQUID
  GASEOUS
}

type WasteDetails {
  code: String
  name: String
  onuCode: String
  packagings: [Packagings]
  otherPackaging: String
  numberOfPackages: Int
  quantity: Float
  quantityType: QuantityType
  consistence: Consistence
}

type Trader {
  company: FormCompany

  receipt: String
  department: String
  validityLimit: DateTime
}

type CompanyStat {
  company: FormCompany
  stats: [Stat]
}

type Stat {
  wasteCode: String
  incoming: Float
  outgoing: Float
}

type FileDownload {
  token: String
  downloadLink: String
}

enum FormsRegisterExportType {
  INCOMING
  OUTGOING
}
 
type StatusLogForm {
  id: ID
  readableId: String
}

type StatusLogUser {
  id: ID
  email: String
}

"""
Changement de statut d'un bordereau

  `status`: statut du bordereau après le changement de statut

  `updatedFields`: valeur des champs transmis lors du changement de statut (eg. receivedBY, processingOperationDescription)
"""
type StatusLog{
  id: ID
  status: FormStatus
  loggedAt: DateTime
  updatedFields: JSON
  form: StatusLogForm
  user: StatusLogUser
}

"""
Informations du cycle de vie des bordereaux

Pagination

  `hasNextPage` et `hasPreviousPage`: pagination, indique si d'autres pages existent avant ou après

  `startCursor`et `endCursor`: premier et dernier ID de la page, à passer dans cursorAfter ou cursorBefore de la query formsLifeCycle

"""
type formsLifeCycleData{
  statusLogs: [StatusLog]
  hasNextPage: Boolean
  hasPreviousPage: Boolean
  startCursor: ID
  endCursor: ID
  count: Int
}

