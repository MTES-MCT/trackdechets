// Code generated by Prisma (prisma@1.21.1). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode, GraphQLSchema } from "graphql";
import { makePrismaClientClass, BaseClientOptions } from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  company: (where?: CompanyWhereInput) => Promise<boolean>;
  emitter: (where?: EmitterWhereInput) => Promise<boolean>;
  form: (where?: FormWhereInput) => Promise<boolean>;
  formCompany: (where?: FormCompanyWhereInput) => Promise<boolean>;
  recipient: (where?: RecipientWhereInput) => Promise<boolean>;
  transporter: (where?: TransporterWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  wasteDetails: (where?: WasteDetailsWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  company: (where: CompanyWhereUniqueInput) => CompanyPromise;
  companies: (
    args?: {
      where?: CompanyWhereInput;
      orderBy?: CompanyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Company>;
  companiesConnection: (
    args?: {
      where?: CompanyWhereInput;
      orderBy?: CompanyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CompanyConnectionPromise;
  emitters: (
    args?: {
      where?: EmitterWhereInput;
      orderBy?: EmitterOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Emitter>;
  emittersConnection: (
    args?: {
      where?: EmitterWhereInput;
      orderBy?: EmitterOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => EmitterConnectionPromise;
  form: (where: FormWhereUniqueInput) => FormPromise;
  forms: (
    args?: {
      where?: FormWhereInput;
      orderBy?: FormOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Form>;
  formsConnection: (
    args?: {
      where?: FormWhereInput;
      orderBy?: FormOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FormConnectionPromise;
  formCompanies: (
    args?: {
      where?: FormCompanyWhereInput;
      orderBy?: FormCompanyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<FormCompany>;
  formCompaniesConnection: (
    args?: {
      where?: FormCompanyWhereInput;
      orderBy?: FormCompanyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FormCompanyConnectionPromise;
  recipients: (
    args?: {
      where?: RecipientWhereInput;
      orderBy?: RecipientOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Recipient>;
  recipientsConnection: (
    args?: {
      where?: RecipientWhereInput;
      orderBy?: RecipientOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => RecipientConnectionPromise;
  transporters: (
    args?: {
      where?: TransporterWhereInput;
      orderBy?: TransporterOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Transporter>;
  transportersConnection: (
    args?: {
      where?: TransporterWhereInput;
      orderBy?: TransporterOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TransporterConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  wasteDetailses: (
    args?: {
      where?: WasteDetailsWhereInput;
      orderBy?: WasteDetailsOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<WasteDetails>;
  wasteDetailsesConnection: (
    args?: {
      where?: WasteDetailsWhereInput;
      orderBy?: WasteDetailsOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => WasteDetailsConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCompany: (data: CompanyCreateInput) => CompanyPromise;
  updateCompany: (
    args: { data: CompanyUpdateInput; where: CompanyWhereUniqueInput }
  ) => CompanyPromise;
  updateManyCompanies: (
    args: { data: CompanyUpdateManyMutationInput; where?: CompanyWhereInput }
  ) => BatchPayloadPromise;
  upsertCompany: (
    args: {
      where: CompanyWhereUniqueInput;
      create: CompanyCreateInput;
      update: CompanyUpdateInput;
    }
  ) => CompanyPromise;
  deleteCompany: (where: CompanyWhereUniqueInput) => CompanyPromise;
  deleteManyCompanies: (where?: CompanyWhereInput) => BatchPayloadPromise;
  createEmitter: (data: EmitterCreateInput) => EmitterPromise;
  updateManyEmitters: (
    args: { data: EmitterUpdateManyMutationInput; where?: EmitterWhereInput }
  ) => BatchPayloadPromise;
  deleteManyEmitters: (where?: EmitterWhereInput) => BatchPayloadPromise;
  createForm: (data: FormCreateInput) => FormPromise;
  updateForm: (
    args: { data: FormUpdateInput; where: FormWhereUniqueInput }
  ) => FormPromise;
  upsertForm: (
    args: {
      where: FormWhereUniqueInput;
      create: FormCreateInput;
      update: FormUpdateInput;
    }
  ) => FormPromise;
  deleteForm: (where: FormWhereUniqueInput) => FormPromise;
  deleteManyForms: (where?: FormWhereInput) => BatchPayloadPromise;
  createFormCompany: (data: FormCompanyCreateInput) => FormCompanyPromise;
  updateManyFormCompanies: (
    args: {
      data: FormCompanyUpdateManyMutationInput;
      where?: FormCompanyWhereInput;
    }
  ) => BatchPayloadPromise;
  deleteManyFormCompanies: (
    where?: FormCompanyWhereInput
  ) => BatchPayloadPromise;
  createRecipient: (data: RecipientCreateInput) => RecipientPromise;
  updateManyRecipients: (
    args: {
      data: RecipientUpdateManyMutationInput;
      where?: RecipientWhereInput;
    }
  ) => BatchPayloadPromise;
  deleteManyRecipients: (where?: RecipientWhereInput) => BatchPayloadPromise;
  createTransporter: (data: TransporterCreateInput) => TransporterPromise;
  updateManyTransporters: (
    args: {
      data: TransporterUpdateManyMutationInput;
      where?: TransporterWhereInput;
    }
  ) => BatchPayloadPromise;
  deleteManyTransporters: (
    where?: TransporterWhereInput
  ) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createWasteDetails: (data: WasteDetailsCreateInput) => WasteDetailsPromise;
  updateManyWasteDetailses: (
    args: {
      data: WasteDetailsUpdateManyMutationInput;
      where?: WasteDetailsWhereInput;
    }
  ) => BatchPayloadPromise;
  deleteManyWasteDetailses: (
    where?: WasteDetailsWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  company: (
    where?: CompanySubscriptionWhereInput
  ) => CompanySubscriptionPayloadSubscription;
  emitter: (
    where?: EmitterSubscriptionWhereInput
  ) => EmitterSubscriptionPayloadSubscription;
  form: (
    where?: FormSubscriptionWhereInput
  ) => FormSubscriptionPayloadSubscription;
  formCompany: (
    where?: FormCompanySubscriptionWhereInput
  ) => FormCompanySubscriptionPayloadSubscription;
  recipient: (
    where?: RecipientSubscriptionWhereInput
  ) => RecipientSubscriptionPayloadSubscription;
  transporter: (
    where?: TransporterSubscriptionWhereInput
  ) => TransporterSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  wasteDetails: (
    where?: WasteDetailsSubscriptionWhereInput
  ) => WasteDetailsSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type FormCompanyOrderByInput =
  | "name_ASC"
  | "name_DESC"
  | "siret_ASC"
  | "siret_DESC"
  | "address_ASC"
  | "address_DESC"
  | "contact_ASC"
  | "contact_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "mail_ASC"
  | "mail_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type EmitterOrderByInput =
  | "type_ASC"
  | "type_DESC"
  | "pickupSite_ASC"
  | "pickupSite_DESC"
  | "companyName_ASC"
  | "companyName_DESC"
  | "companySiret_ASC"
  | "companySiret_DESC"
  | "companyAddress_ASC"
  | "companyAddress_DESC"
  | "companyContact_ASC"
  | "companyContact_DESC"
  | "companyPhone_ASC"
  | "companyPhone_DESC"
  | "companyMail_ASC"
  | "companyMail_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type EmitterType = "PRODUCER" | "OTHER";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type QuantityType = "REAL" | "ESTIMATED";

export type FormOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type WasteDetailsOrderByInput =
  | "code_ASC"
  | "code_DESC"
  | "onuCode_ASC"
  | "onuCode_DESC"
  | "packaging_ASC"
  | "packaging_DESC"
  | "numberOfPackages_ASC"
  | "numberOfPackages_DESC"
  | "quantity_ASC"
  | "quantity_DESC"
  | "quantityType_ASC"
  | "quantityType_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type RecipientOrderByInput =
  | "cap_ASC"
  | "cap_DESC"
  | "processingOperation_ASC"
  | "processingOperation_DESC"
  | "companyName_ASC"
  | "companyName_DESC"
  | "companySiret_ASC"
  | "companySiret_DESC"
  | "companyAddress_ASC"
  | "companyAddress_DESC"
  | "companyContact_ASC"
  | "companyContact_DESC"
  | "companyPhone_ASC"
  | "companyPhone_DESC"
  | "companyMail_ASC"
  | "companyMail_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TransporterOrderByInput =
  | "companyName_ASC"
  | "companyName_DESC"
  | "companySiret_ASC"
  | "companySiret_DESC"
  | "companyAddress_ASC"
  | "companyAddress_DESC"
  | "companyContact_ASC"
  | "companyContact_DESC"
  | "companyPhone_ASC"
  | "companyPhone_DESC"
  | "companyMail_ASC"
  | "companyMail_DESC"
  | "receipt_ASC"
  | "receipt_DESC"
  | "department_ASC"
  | "department_DESC"
  | "validityLimit_ASC"
  | "validityLimit_DESC"
  | "contact_ASC"
  | "contact_DESC"
  | "numberPlate_ASC"
  | "numberPlate_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "name_ASC"
  | "name_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CompanyOrderByInput =
  | "siret_ASC"
  | "siret_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export interface FormCompanyWhereInput {
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  siret?: String;
  siret_not?: String;
  siret_in?: String[] | String;
  siret_not_in?: String[] | String;
  siret_lt?: String;
  siret_lte?: String;
  siret_gt?: String;
  siret_gte?: String;
  siret_contains?: String;
  siret_not_contains?: String;
  siret_starts_with?: String;
  siret_not_starts_with?: String;
  siret_ends_with?: String;
  siret_not_ends_with?: String;
  address?: String;
  address_not?: String;
  address_in?: String[] | String;
  address_not_in?: String[] | String;
  address_lt?: String;
  address_lte?: String;
  address_gt?: String;
  address_gte?: String;
  address_contains?: String;
  address_not_contains?: String;
  address_starts_with?: String;
  address_not_starts_with?: String;
  address_ends_with?: String;
  address_not_ends_with?: String;
  contact?: String;
  contact_not?: String;
  contact_in?: String[] | String;
  contact_not_in?: String[] | String;
  contact_lt?: String;
  contact_lte?: String;
  contact_gt?: String;
  contact_gte?: String;
  contact_contains?: String;
  contact_not_contains?: String;
  contact_starts_with?: String;
  contact_not_starts_with?: String;
  contact_ends_with?: String;
  contact_not_ends_with?: String;
  phone?: Int;
  phone_not?: Int;
  phone_in?: Int[] | Int;
  phone_not_in?: Int[] | Int;
  phone_lt?: Int;
  phone_lte?: Int;
  phone_gt?: Int;
  phone_gte?: Int;
  mail?: String;
  mail_not?: String;
  mail_in?: String[] | String;
  mail_not_in?: String[] | String;
  mail_lt?: String;
  mail_lte?: String;
  mail_gt?: String;
  mail_gte?: String;
  mail_contains?: String;
  mail_not_contains?: String;
  mail_starts_with?: String;
  mail_not_starts_with?: String;
  mail_ends_with?: String;
  mail_not_ends_with?: String;
  AND?: FormCompanyWhereInput[] | FormCompanyWhereInput;
  OR?: FormCompanyWhereInput[] | FormCompanyWhereInput;
  NOT?: FormCompanyWhereInput[] | FormCompanyWhereInput;
}

export interface RecipientCreateOneInput {
  create?: RecipientCreateInput;
}

export interface EmitterUpdateDataInput {
  type?: EmitterType;
  pickupSite?: String;
  companyName?: String;
  companySiret?: String;
  companyAddress?: String;
  companyContact?: String;
  companyPhone?: Int;
  companyMail?: String;
}

export type CompanyWhereUniqueInput = AtLeastOne<{
  siret: Int;
}>;

export interface EmitterUpdateOneInput {
  create?: EmitterCreateInput;
  update?: EmitterUpdateDataInput;
  upsert?: EmitterUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
}

export interface EmitterWhereInput {
  type?: EmitterType;
  type_not?: EmitterType;
  type_in?: EmitterType[] | EmitterType;
  type_not_in?: EmitterType[] | EmitterType;
  pickupSite?: String;
  pickupSite_not?: String;
  pickupSite_in?: String[] | String;
  pickupSite_not_in?: String[] | String;
  pickupSite_lt?: String;
  pickupSite_lte?: String;
  pickupSite_gt?: String;
  pickupSite_gte?: String;
  pickupSite_contains?: String;
  pickupSite_not_contains?: String;
  pickupSite_starts_with?: String;
  pickupSite_not_starts_with?: String;
  pickupSite_ends_with?: String;
  pickupSite_not_ends_with?: String;
  companyName?: String;
  companyName_not?: String;
  companyName_in?: String[] | String;
  companyName_not_in?: String[] | String;
  companyName_lt?: String;
  companyName_lte?: String;
  companyName_gt?: String;
  companyName_gte?: String;
  companyName_contains?: String;
  companyName_not_contains?: String;
  companyName_starts_with?: String;
  companyName_not_starts_with?: String;
  companyName_ends_with?: String;
  companyName_not_ends_with?: String;
  companySiret?: String;
  companySiret_not?: String;
  companySiret_in?: String[] | String;
  companySiret_not_in?: String[] | String;
  companySiret_lt?: String;
  companySiret_lte?: String;
  companySiret_gt?: String;
  companySiret_gte?: String;
  companySiret_contains?: String;
  companySiret_not_contains?: String;
  companySiret_starts_with?: String;
  companySiret_not_starts_with?: String;
  companySiret_ends_with?: String;
  companySiret_not_ends_with?: String;
  companyAddress?: String;
  companyAddress_not?: String;
  companyAddress_in?: String[] | String;
  companyAddress_not_in?: String[] | String;
  companyAddress_lt?: String;
  companyAddress_lte?: String;
  companyAddress_gt?: String;
  companyAddress_gte?: String;
  companyAddress_contains?: String;
  companyAddress_not_contains?: String;
  companyAddress_starts_with?: String;
  companyAddress_not_starts_with?: String;
  companyAddress_ends_with?: String;
  companyAddress_not_ends_with?: String;
  companyContact?: String;
  companyContact_not?: String;
  companyContact_in?: String[] | String;
  companyContact_not_in?: String[] | String;
  companyContact_lt?: String;
  companyContact_lte?: String;
  companyContact_gt?: String;
  companyContact_gte?: String;
  companyContact_contains?: String;
  companyContact_not_contains?: String;
  companyContact_starts_with?: String;
  companyContact_not_starts_with?: String;
  companyContact_ends_with?: String;
  companyContact_not_ends_with?: String;
  companyPhone?: Int;
  companyPhone_not?: Int;
  companyPhone_in?: Int[] | Int;
  companyPhone_not_in?: Int[] | Int;
  companyPhone_lt?: Int;
  companyPhone_lte?: Int;
  companyPhone_gt?: Int;
  companyPhone_gte?: Int;
  companyMail?: String;
  companyMail_not?: String;
  companyMail_in?: String[] | String;
  companyMail_not_in?: String[] | String;
  companyMail_lt?: String;
  companyMail_lte?: String;
  companyMail_gt?: String;
  companyMail_gte?: String;
  companyMail_contains?: String;
  companyMail_not_contains?: String;
  companyMail_starts_with?: String;
  companyMail_not_starts_with?: String;
  companyMail_ends_with?: String;
  companyMail_not_ends_with?: String;
  AND?: EmitterWhereInput[] | EmitterWhereInput;
  OR?: EmitterWhereInput[] | EmitterWhereInput;
  NOT?: EmitterWhereInput[] | EmitterWhereInput;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface WasteDetailsUpdateManyMutationInput {
  code?: String;
  onuCode?: String;
  packaging?: String;
  numberOfPackages?: Int;
  quantity?: Float;
  quantityType?: QuantityType;
}

export interface TransporterSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TransporterWhereInput;
  AND?: TransporterSubscriptionWhereInput[] | TransporterSubscriptionWhereInput;
  OR?: TransporterSubscriptionWhereInput[] | TransporterSubscriptionWhereInput;
  NOT?: TransporterSubscriptionWhereInput[] | TransporterSubscriptionWhereInput;
}

export type FormWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CompanyUpsertNestedInput {
  update: CompanyUpdateDataInput;
  create: CompanyCreateInput;
}

export interface TransporterUpdateManyMutationInput {
  companyName?: String;
  companySiret?: String;
  companyAddress?: String;
  companyContact?: String;
  companyPhone?: Int;
  companyMail?: String;
  receipt?: String;
  department?: String;
  validityLimit?: DateTimeInput;
  contact?: String;
  numberPlate?: String;
}

export interface CompanyUpdateDataInput {
  siret?: Int;
}

export interface FormCompanyUpdateManyMutationInput {
  name?: String;
  siret?: String;
  address?: String;
  contact?: String;
  phone?: Int;
  mail?: String;
}

export interface CompanyUpdateOneInput {
  create?: CompanyCreateInput;
  update?: CompanyUpdateDataInput;
  upsert?: CompanyUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: CompanyWhereUniqueInput;
}

export interface WasteDetailsUpsertNestedInput {
  update: WasteDetailsUpdateDataInput;
  create: WasteDetailsCreateInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
}>;

export interface WasteDetailsUpdateOneInput {
  create?: WasteDetailsCreateInput;
  update?: WasteDetailsUpdateDataInput;
  upsert?: WasteDetailsUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface FormWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  owner?: UserWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  emitter?: EmitterWhereInput;
  recipient?: RecipientWhereInput;
  transporter?: TransporterWhereInput;
  wasteDetails?: WasteDetailsWhereInput;
  AND?: FormWhereInput[] | FormWhereInput;
  OR?: FormWhereInput[] | FormWhereInput;
  NOT?: FormWhereInput[] | FormWhereInput;
}

export interface UserUpdateDataInput {
  email?: String;
  password?: String;
  name?: String;
  phone?: String;
  company?: CompanyUpdateOneInput;
}

export interface RecipientWhereInput {
  cap?: String;
  cap_not?: String;
  cap_in?: String[] | String;
  cap_not_in?: String[] | String;
  cap_lt?: String;
  cap_lte?: String;
  cap_gt?: String;
  cap_gte?: String;
  cap_contains?: String;
  cap_not_contains?: String;
  cap_starts_with?: String;
  cap_not_starts_with?: String;
  cap_ends_with?: String;
  cap_not_ends_with?: String;
  processingOperation?: String;
  processingOperation_not?: String;
  processingOperation_in?: String[] | String;
  processingOperation_not_in?: String[] | String;
  processingOperation_lt?: String;
  processingOperation_lte?: String;
  processingOperation_gt?: String;
  processingOperation_gte?: String;
  processingOperation_contains?: String;
  processingOperation_not_contains?: String;
  processingOperation_starts_with?: String;
  processingOperation_not_starts_with?: String;
  processingOperation_ends_with?: String;
  processingOperation_not_ends_with?: String;
  companyName?: String;
  companyName_not?: String;
  companyName_in?: String[] | String;
  companyName_not_in?: String[] | String;
  companyName_lt?: String;
  companyName_lte?: String;
  companyName_gt?: String;
  companyName_gte?: String;
  companyName_contains?: String;
  companyName_not_contains?: String;
  companyName_starts_with?: String;
  companyName_not_starts_with?: String;
  companyName_ends_with?: String;
  companyName_not_ends_with?: String;
  companySiret?: String;
  companySiret_not?: String;
  companySiret_in?: String[] | String;
  companySiret_not_in?: String[] | String;
  companySiret_lt?: String;
  companySiret_lte?: String;
  companySiret_gt?: String;
  companySiret_gte?: String;
  companySiret_contains?: String;
  companySiret_not_contains?: String;
  companySiret_starts_with?: String;
  companySiret_not_starts_with?: String;
  companySiret_ends_with?: String;
  companySiret_not_ends_with?: String;
  companyAddress?: String;
  companyAddress_not?: String;
  companyAddress_in?: String[] | String;
  companyAddress_not_in?: String[] | String;
  companyAddress_lt?: String;
  companyAddress_lte?: String;
  companyAddress_gt?: String;
  companyAddress_gte?: String;
  companyAddress_contains?: String;
  companyAddress_not_contains?: String;
  companyAddress_starts_with?: String;
  companyAddress_not_starts_with?: String;
  companyAddress_ends_with?: String;
  companyAddress_not_ends_with?: String;
  companyContact?: String;
  companyContact_not?: String;
  companyContact_in?: String[] | String;
  companyContact_not_in?: String[] | String;
  companyContact_lt?: String;
  companyContact_lte?: String;
  companyContact_gt?: String;
  companyContact_gte?: String;
  companyContact_contains?: String;
  companyContact_not_contains?: String;
  companyContact_starts_with?: String;
  companyContact_not_starts_with?: String;
  companyContact_ends_with?: String;
  companyContact_not_ends_with?: String;
  companyPhone?: Int;
  companyPhone_not?: Int;
  companyPhone_in?: Int[] | Int;
  companyPhone_not_in?: Int[] | Int;
  companyPhone_lt?: Int;
  companyPhone_lte?: Int;
  companyPhone_gt?: Int;
  companyPhone_gte?: Int;
  companyMail?: String;
  companyMail_not?: String;
  companyMail_in?: String[] | String;
  companyMail_not_in?: String[] | String;
  companyMail_lt?: String;
  companyMail_lte?: String;
  companyMail_gt?: String;
  companyMail_gte?: String;
  companyMail_contains?: String;
  companyMail_not_contains?: String;
  companyMail_starts_with?: String;
  companyMail_not_starts_with?: String;
  companyMail_ends_with?: String;
  companyMail_not_ends_with?: String;
  AND?: RecipientWhereInput[] | RecipientWhereInput;
  OR?: RecipientWhereInput[] | RecipientWhereInput;
  NOT?: RecipientWhereInput[] | RecipientWhereInput;
}

export interface UserUpdateOneRequiredInput {
  create?: UserCreateInput;
  update?: UserUpdateDataInput;
  upsert?: UserUpsertNestedInput;
  connect?: UserWhereUniqueInput;
}

export interface WasteDetailsWhereInput {
  code?: String;
  code_not?: String;
  code_in?: String[] | String;
  code_not_in?: String[] | String;
  code_lt?: String;
  code_lte?: String;
  code_gt?: String;
  code_gte?: String;
  code_contains?: String;
  code_not_contains?: String;
  code_starts_with?: String;
  code_not_starts_with?: String;
  code_ends_with?: String;
  code_not_ends_with?: String;
  onuCode?: String;
  onuCode_not?: String;
  onuCode_in?: String[] | String;
  onuCode_not_in?: String[] | String;
  onuCode_lt?: String;
  onuCode_lte?: String;
  onuCode_gt?: String;
  onuCode_gte?: String;
  onuCode_contains?: String;
  onuCode_not_contains?: String;
  onuCode_starts_with?: String;
  onuCode_not_starts_with?: String;
  onuCode_ends_with?: String;
  onuCode_not_ends_with?: String;
  packaging?: String;
  packaging_not?: String;
  packaging_in?: String[] | String;
  packaging_not_in?: String[] | String;
  packaging_lt?: String;
  packaging_lte?: String;
  packaging_gt?: String;
  packaging_gte?: String;
  packaging_contains?: String;
  packaging_not_contains?: String;
  packaging_starts_with?: String;
  packaging_not_starts_with?: String;
  packaging_ends_with?: String;
  packaging_not_ends_with?: String;
  numberOfPackages?: Int;
  numberOfPackages_not?: Int;
  numberOfPackages_in?: Int[] | Int;
  numberOfPackages_not_in?: Int[] | Int;
  numberOfPackages_lt?: Int;
  numberOfPackages_lte?: Int;
  numberOfPackages_gt?: Int;
  numberOfPackages_gte?: Int;
  quantity?: Float;
  quantity_not?: Float;
  quantity_in?: Float[] | Float;
  quantity_not_in?: Float[] | Float;
  quantity_lt?: Float;
  quantity_lte?: Float;
  quantity_gt?: Float;
  quantity_gte?: Float;
  quantityType?: QuantityType;
  quantityType_not?: QuantityType;
  quantityType_in?: QuantityType[] | QuantityType;
  quantityType_not_in?: QuantityType[] | QuantityType;
  AND?: WasteDetailsWhereInput[] | WasteDetailsWhereInput;
  OR?: WasteDetailsWhereInput[] | WasteDetailsWhereInput;
  NOT?: WasteDetailsWhereInput[] | WasteDetailsWhereInput;
}

export interface FormUpdateInput {
  owner?: UserUpdateOneRequiredInput;
  emitter?: EmitterUpdateOneInput;
  recipient?: RecipientUpdateOneInput;
  transporter?: TransporterUpdateOneInput;
  wasteDetails?: WasteDetailsUpdateOneInput;
}

export interface TransporterUpsertNestedInput {
  update: TransporterUpdateDataInput;
  create: TransporterCreateInput;
}

export interface CompanyWhereInput {
  siret?: Int;
  siret_not?: Int;
  siret_in?: Int[] | Int;
  siret_not_in?: Int[] | Int;
  siret_lt?: Int;
  siret_lte?: Int;
  siret_gt?: Int;
  siret_gte?: Int;
  AND?: CompanyWhereInput[] | CompanyWhereInput;
  OR?: CompanyWhereInput[] | CompanyWhereInput;
  NOT?: CompanyWhereInput[] | CompanyWhereInput;
}

export interface TransporterUpdateOneInput {
  create?: TransporterCreateInput;
  update?: TransporterUpdateDataInput;
  upsert?: TransporterUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
}

export interface WasteDetailsCreateInput {
  code?: String;
  onuCode?: String;
  packaging?: String;
  numberOfPackages?: Int;
  quantity?: Float;
  quantityType?: QuantityType;
}

export interface FormCompanySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: FormCompanyWhereInput;
  AND?: FormCompanySubscriptionWhereInput[] | FormCompanySubscriptionWhereInput;
  OR?: FormCompanySubscriptionWhereInput[] | FormCompanySubscriptionWhereInput;
  NOT?: FormCompanySubscriptionWhereInput[] | FormCompanySubscriptionWhereInput;
}

export interface WasteDetailsCreateOneInput {
  create?: WasteDetailsCreateInput;
}

export interface RecipientUpdateDataInput {
  cap?: String;
  processingOperation?: String;
  companyName?: String;
  companySiret?: String;
  companyAddress?: String;
  companyContact?: String;
  companyPhone?: Int;
  companyMail?: String;
}

export interface TransporterCreateInput {
  companyName?: String;
  companySiret?: String;
  companyAddress?: String;
  companyContact?: String;
  companyPhone?: Int;
  companyMail?: String;
  receipt?: String;
  department?: String;
  validityLimit?: DateTimeInput;
  contact?: String;
  numberPlate?: String;
}

export interface EmitterUpsertNestedInput {
  update: EmitterUpdateDataInput;
  create: EmitterCreateInput;
}

export interface CompanySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CompanyWhereInput;
  AND?: CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput;
  OR?: CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput;
  NOT?: CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput;
}

export interface UserUpdateInput {
  email?: String;
  password?: String;
  name?: String;
  phone?: String;
  company?: CompanyUpdateOneInput;
}

export interface CompanyCreateInput {
  siret: Int;
}

export interface FormCompanyCreateInput {
  name?: String;
  siret?: String;
  address?: String;
  contact?: String;
  phone?: Int;
  mail?: String;
}

export interface CompanyUpdateInput {
  siret?: Int;
}

export interface EmitterSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: EmitterWhereInput;
  AND?: EmitterSubscriptionWhereInput[] | EmitterSubscriptionWhereInput;
  OR?: EmitterSubscriptionWhereInput[] | EmitterSubscriptionWhereInput;
  NOT?: EmitterSubscriptionWhereInput[] | EmitterSubscriptionWhereInput;
}

export interface CompanyUpdateManyMutationInput {
  siret?: Int;
}

export interface TransporterWhereInput {
  companyName?: String;
  companyName_not?: String;
  companyName_in?: String[] | String;
  companyName_not_in?: String[] | String;
  companyName_lt?: String;
  companyName_lte?: String;
  companyName_gt?: String;
  companyName_gte?: String;
  companyName_contains?: String;
  companyName_not_contains?: String;
  companyName_starts_with?: String;
  companyName_not_starts_with?: String;
  companyName_ends_with?: String;
  companyName_not_ends_with?: String;
  companySiret?: String;
  companySiret_not?: String;
  companySiret_in?: String[] | String;
  companySiret_not_in?: String[] | String;
  companySiret_lt?: String;
  companySiret_lte?: String;
  companySiret_gt?: String;
  companySiret_gte?: String;
  companySiret_contains?: String;
  companySiret_not_contains?: String;
  companySiret_starts_with?: String;
  companySiret_not_starts_with?: String;
  companySiret_ends_with?: String;
  companySiret_not_ends_with?: String;
  companyAddress?: String;
  companyAddress_not?: String;
  companyAddress_in?: String[] | String;
  companyAddress_not_in?: String[] | String;
  companyAddress_lt?: String;
  companyAddress_lte?: String;
  companyAddress_gt?: String;
  companyAddress_gte?: String;
  companyAddress_contains?: String;
  companyAddress_not_contains?: String;
  companyAddress_starts_with?: String;
  companyAddress_not_starts_with?: String;
  companyAddress_ends_with?: String;
  companyAddress_not_ends_with?: String;
  companyContact?: String;
  companyContact_not?: String;
  companyContact_in?: String[] | String;
  companyContact_not_in?: String[] | String;
  companyContact_lt?: String;
  companyContact_lte?: String;
  companyContact_gt?: String;
  companyContact_gte?: String;
  companyContact_contains?: String;
  companyContact_not_contains?: String;
  companyContact_starts_with?: String;
  companyContact_not_starts_with?: String;
  companyContact_ends_with?: String;
  companyContact_not_ends_with?: String;
  companyPhone?: Int;
  companyPhone_not?: Int;
  companyPhone_in?: Int[] | Int;
  companyPhone_not_in?: Int[] | Int;
  companyPhone_lt?: Int;
  companyPhone_lte?: Int;
  companyPhone_gt?: Int;
  companyPhone_gte?: Int;
  companyMail?: String;
  companyMail_not?: String;
  companyMail_in?: String[] | String;
  companyMail_not_in?: String[] | String;
  companyMail_lt?: String;
  companyMail_lte?: String;
  companyMail_gt?: String;
  companyMail_gte?: String;
  companyMail_contains?: String;
  companyMail_not_contains?: String;
  companyMail_starts_with?: String;
  companyMail_not_starts_with?: String;
  companyMail_ends_with?: String;
  companyMail_not_ends_with?: String;
  receipt?: String;
  receipt_not?: String;
  receipt_in?: String[] | String;
  receipt_not_in?: String[] | String;
  receipt_lt?: String;
  receipt_lte?: String;
  receipt_gt?: String;
  receipt_gte?: String;
  receipt_contains?: String;
  receipt_not_contains?: String;
  receipt_starts_with?: String;
  receipt_not_starts_with?: String;
  receipt_ends_with?: String;
  receipt_not_ends_with?: String;
  department?: String;
  department_not?: String;
  department_in?: String[] | String;
  department_not_in?: String[] | String;
  department_lt?: String;
  department_lte?: String;
  department_gt?: String;
  department_gte?: String;
  department_contains?: String;
  department_not_contains?: String;
  department_starts_with?: String;
  department_not_starts_with?: String;
  department_ends_with?: String;
  department_not_ends_with?: String;
  validityLimit?: DateTimeInput;
  validityLimit_not?: DateTimeInput;
  validityLimit_in?: DateTimeInput[] | DateTimeInput;
  validityLimit_not_in?: DateTimeInput[] | DateTimeInput;
  validityLimit_lt?: DateTimeInput;
  validityLimit_lte?: DateTimeInput;
  validityLimit_gt?: DateTimeInput;
  validityLimit_gte?: DateTimeInput;
  contact?: String;
  contact_not?: String;
  contact_in?: String[] | String;
  contact_not_in?: String[] | String;
  contact_lt?: String;
  contact_lte?: String;
  contact_gt?: String;
  contact_gte?: String;
  contact_contains?: String;
  contact_not_contains?: String;
  contact_starts_with?: String;
  contact_not_starts_with?: String;
  contact_ends_with?: String;
  contact_not_ends_with?: String;
  numberPlate?: String;
  numberPlate_not?: String;
  numberPlate_in?: String[] | String;
  numberPlate_not_in?: String[] | String;
  numberPlate_lt?: String;
  numberPlate_lte?: String;
  numberPlate_gt?: String;
  numberPlate_gte?: String;
  numberPlate_contains?: String;
  numberPlate_not_contains?: String;
  numberPlate_starts_with?: String;
  numberPlate_not_starts_with?: String;
  numberPlate_ends_with?: String;
  numberPlate_not_ends_with?: String;
  AND?: TransporterWhereInput[] | TransporterWhereInput;
  OR?: TransporterWhereInput[] | TransporterWhereInput;
  NOT?: TransporterWhereInput[] | TransporterWhereInput;
}

export interface TransporterCreateOneInput {
  create?: TransporterCreateInput;
}

export interface TransporterUpdateDataInput {
  companyName?: String;
  companySiret?: String;
  companyAddress?: String;
  companyContact?: String;
  companyPhone?: Int;
  companyMail?: String;
  receipt?: String;
  department?: String;
  validityLimit?: DateTimeInput;
  contact?: String;
  numberPlate?: String;
}

export interface RecipientCreateInput {
  cap?: String;
  processingOperation?: String;
  companyName?: String;
  companySiret?: String;
  companyAddress?: String;
  companyContact?: String;
  companyPhone?: Int;
  companyMail?: String;
}

export interface RecipientUpsertNestedInput {
  update: RecipientUpdateDataInput;
  create: RecipientCreateInput;
}

export interface EmitterCreateInput {
  type?: EmitterType;
  pickupSite?: String;
  companyName?: String;
  companySiret?: String;
  companyAddress?: String;
  companyContact?: String;
  companyPhone?: Int;
  companyMail?: String;
}

export interface RecipientSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: RecipientWhereInput;
  AND?: RecipientSubscriptionWhereInput[] | RecipientSubscriptionWhereInput;
  OR?: RecipientSubscriptionWhereInput[] | RecipientSubscriptionWhereInput;
  NOT?: RecipientSubscriptionWhereInput[] | RecipientSubscriptionWhereInput;
}

export interface EmitterUpdateManyMutationInput {
  type?: EmitterType;
  pickupSite?: String;
  companyName?: String;
  companySiret?: String;
  companyAddress?: String;
  companyContact?: String;
  companyPhone?: Int;
  companyMail?: String;
}

export interface RecipientUpdateManyMutationInput {
  cap?: String;
  processingOperation?: String;
  companyName?: String;
  companySiret?: String;
  companyAddress?: String;
  companyContact?: String;
  companyPhone?: Int;
  companyMail?: String;
}

export interface FormCreateInput {
  owner: UserCreateOneInput;
  emitter?: EmitterCreateOneInput;
  recipient?: RecipientCreateOneInput;
  transporter?: TransporterCreateOneInput;
  wasteDetails?: WasteDetailsCreateOneInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  phone?: String;
  phone_not?: String;
  phone_in?: String[] | String;
  phone_not_in?: String[] | String;
  phone_lt?: String;
  phone_lte?: String;
  phone_gt?: String;
  phone_gte?: String;
  phone_contains?: String;
  phone_not_contains?: String;
  phone_starts_with?: String;
  phone_not_starts_with?: String;
  phone_ends_with?: String;
  phone_not_ends_with?: String;
  company?: CompanyWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface EmitterCreateOneInput {
  create?: EmitterCreateInput;
}

export interface CompanyCreateOneInput {
  create?: CompanyCreateInput;
  connect?: CompanyWhereUniqueInput;
}

export interface UserCreateInput {
  email: String;
  password: String;
  name?: String;
  phone?: String;
  company?: CompanyCreateOneInput;
}

export interface UserCreateOneInput {
  create?: UserCreateInput;
  connect?: UserWhereUniqueInput;
}

export interface FormSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: FormWhereInput;
  AND?: FormSubscriptionWhereInput[] | FormSubscriptionWhereInput;
  OR?: FormSubscriptionWhereInput[] | FormSubscriptionWhereInput;
  NOT?: FormSubscriptionWhereInput[] | FormSubscriptionWhereInput;
}

export interface WasteDetailsUpdateDataInput {
  code?: String;
  onuCode?: String;
  packaging?: String;
  numberOfPackages?: Int;
  quantity?: Float;
  quantityType?: QuantityType;
}

export interface UserUpdateManyMutationInput {
  email?: String;
  password?: String;
  name?: String;
  phone?: String;
}

export interface RecipientUpdateOneInput {
  create?: RecipientCreateInput;
  update?: RecipientUpdateDataInput;
  upsert?: RecipientUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
}

export interface WasteDetailsSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: WasteDetailsWhereInput;
  AND?:
    | WasteDetailsSubscriptionWhereInput[]
    | WasteDetailsSubscriptionWhereInput;
  OR?:
    | WasteDetailsSubscriptionWhereInput[]
    | WasteDetailsSubscriptionWhereInput;
  NOT?:
    | WasteDetailsSubscriptionWhereInput[]
    | WasteDetailsSubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface WasteDetailsPreviousValues {
  code?: String;
  onuCode?: String;
  packaging?: String;
  numberOfPackages?: Int;
  quantity?: Float;
  quantityType?: QuantityType;
}

export interface WasteDetailsPreviousValuesPromise
  extends Promise<WasteDetailsPreviousValues>,
    Fragmentable {
  code: () => Promise<String>;
  onuCode: () => Promise<String>;
  packaging: () => Promise<String>;
  numberOfPackages: () => Promise<Int>;
  quantity: () => Promise<Float>;
  quantityType: () => Promise<QuantityType>;
}

export interface WasteDetailsPreviousValuesSubscription
  extends Promise<AsyncIterator<WasteDetailsPreviousValues>>,
    Fragmentable {
  code: () => Promise<AsyncIterator<String>>;
  onuCode: () => Promise<AsyncIterator<String>>;
  packaging: () => Promise<AsyncIterator<String>>;
  numberOfPackages: () => Promise<AsyncIterator<Int>>;
  quantity: () => Promise<AsyncIterator<Float>>;
  quantityType: () => Promise<AsyncIterator<QuantityType>>;
}

export interface User {
  id: ID_Output;
  email: String;
  password: String;
  name?: String;
  phone?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  name: () => Promise<String>;
  phone: () => Promise<String>;
  company: <T = CompanyPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  company: <T = CompanySubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface Form {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface FormPromise extends Promise<Form>, Fragmentable {
  id: () => Promise<ID_Output>;
  owner: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  emitter: <T = EmitterPromise>() => T;
  recipient: <T = RecipientPromise>() => T;
  transporter: <T = TransporterPromise>() => T;
  wasteDetails: <T = WasteDetailsPromise>() => T;
}

export interface FormSubscription
  extends Promise<AsyncIterator<Form>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  owner: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  emitter: <T = EmitterSubscription>() => T;
  recipient: <T = RecipientSubscription>() => T;
  transporter: <T = TransporterSubscription>() => T;
  wasteDetails: <T = WasteDetailsSubscription>() => T;
}

export interface WasteDetailsEdge {
  cursor: String;
}

export interface WasteDetailsEdgePromise
  extends Promise<WasteDetailsEdge>,
    Fragmentable {
  node: <T = WasteDetailsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface WasteDetailsEdgeSubscription
  extends Promise<AsyncIterator<WasteDetailsEdge>>,
    Fragmentable {
  node: <T = WasteDetailsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateEmitter {
  count: Int;
}

export interface AggregateEmitterPromise
  extends Promise<AggregateEmitter>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEmitterSubscription
  extends Promise<AsyncIterator<AggregateEmitter>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface EmitterEdge {
  cursor: String;
}

export interface EmitterEdgePromise extends Promise<EmitterEdge>, Fragmentable {
  node: <T = EmitterPromise>() => T;
  cursor: () => Promise<String>;
}

export interface EmitterEdgeSubscription
  extends Promise<AsyncIterator<EmitterEdge>>,
    Fragmentable {
  node: <T = EmitterSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TransporterEdge {
  cursor: String;
}

export interface TransporterEdgePromise
  extends Promise<TransporterEdge>,
    Fragmentable {
  node: <T = TransporterPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TransporterEdgeSubscription
  extends Promise<AsyncIterator<TransporterEdge>>,
    Fragmentable {
  node: <T = TransporterSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface EmitterConnection {}

export interface EmitterConnectionPromise
  extends Promise<EmitterConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EmitterEdge>>() => T;
  aggregate: <T = AggregateEmitterPromise>() => T;
}

export interface EmitterConnectionSubscription
  extends Promise<AsyncIterator<EmitterConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EmitterEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEmitterSubscription>() => T;
}

export interface AggregateRecipient {
  count: Int;
}

export interface AggregateRecipientPromise
  extends Promise<AggregateRecipient>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRecipientSubscription
  extends Promise<AsyncIterator<AggregateRecipient>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Emitter {
  type?: EmitterType;
  pickupSite?: String;
  companyName?: String;
  companySiret?: String;
  companyAddress?: String;
  companyContact?: String;
  companyPhone?: Int;
  companyMail?: String;
}

export interface EmitterPromise extends Promise<Emitter>, Fragmentable {
  type: () => Promise<EmitterType>;
  pickupSite: () => Promise<String>;
  companyName: () => Promise<String>;
  companySiret: () => Promise<String>;
  companyAddress: () => Promise<String>;
  companyContact: () => Promise<String>;
  companyPhone: () => Promise<Int>;
  companyMail: () => Promise<String>;
}

export interface EmitterSubscription
  extends Promise<AsyncIterator<Emitter>>,
    Fragmentable {
  type: () => Promise<AsyncIterator<EmitterType>>;
  pickupSite: () => Promise<AsyncIterator<String>>;
  companyName: () => Promise<AsyncIterator<String>>;
  companySiret: () => Promise<AsyncIterator<String>>;
  companyAddress: () => Promise<AsyncIterator<String>>;
  companyContact: () => Promise<AsyncIterator<String>>;
  companyPhone: () => Promise<AsyncIterator<Int>>;
  companyMail: () => Promise<AsyncIterator<String>>;
}

export interface RecipientConnection {}

export interface RecipientConnectionPromise
  extends Promise<RecipientConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RecipientEdge>>() => T;
  aggregate: <T = AggregateRecipientPromise>() => T;
}

export interface RecipientConnectionSubscription
  extends Promise<AsyncIterator<RecipientConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RecipientEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRecipientSubscription>() => T;
}

export interface CompanySubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface CompanySubscriptionPayloadPromise
  extends Promise<CompanySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CompanyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CompanyPreviousValuesPromise>() => T;
}

export interface CompanySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CompanySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CompanySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CompanyPreviousValuesSubscription>() => T;
}

export interface FormCompanyEdge {
  cursor: String;
}

export interface FormCompanyEdgePromise
  extends Promise<FormCompanyEdge>,
    Fragmentable {
  node: <T = FormCompanyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FormCompanyEdgeSubscription
  extends Promise<AsyncIterator<FormCompanyEdge>>,
    Fragmentable {
  node: <T = FormCompanySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CompanyPreviousValues {
  siret: Int;
}

export interface CompanyPreviousValuesPromise
  extends Promise<CompanyPreviousValues>,
    Fragmentable {
  siret: () => Promise<Int>;
}

export interface CompanyPreviousValuesSubscription
  extends Promise<AsyncIterator<CompanyPreviousValues>>,
    Fragmentable {
  siret: () => Promise<AsyncIterator<Int>>;
}

export interface FormCompany {
  name?: String;
  siret?: String;
  address?: String;
  contact?: String;
  phone?: Int;
  mail?: String;
}

export interface FormCompanyPromise extends Promise<FormCompany>, Fragmentable {
  name: () => Promise<String>;
  siret: () => Promise<String>;
  address: () => Promise<String>;
  contact: () => Promise<String>;
  phone: () => Promise<Int>;
  mail: () => Promise<String>;
}

export interface FormCompanySubscription
  extends Promise<AsyncIterator<FormCompany>>,
    Fragmentable {
  name: () => Promise<AsyncIterator<String>>;
  siret: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  contact: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<Int>>;
  mail: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCompany {
  count: Int;
}

export interface AggregateCompanyPromise
  extends Promise<AggregateCompany>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCompanySubscription
  extends Promise<AsyncIterator<AggregateCompany>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FormEdge {
  cursor: String;
}

export interface FormEdgePromise extends Promise<FormEdge>, Fragmentable {
  node: <T = FormPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FormEdgeSubscription
  extends Promise<AsyncIterator<FormEdge>>,
    Fragmentable {
  node: <T = FormSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface EmitterSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface EmitterSubscriptionPayloadPromise
  extends Promise<EmitterSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EmitterPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EmitterPreviousValuesPromise>() => T;
}

export interface EmitterSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EmitterSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EmitterSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EmitterPreviousValuesSubscription>() => T;
}

export interface WasteDetailsSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface WasteDetailsSubscriptionPayloadPromise
  extends Promise<WasteDetailsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = WasteDetailsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = WasteDetailsPreviousValuesPromise>() => T;
}

export interface WasteDetailsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<WasteDetailsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = WasteDetailsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = WasteDetailsPreviousValuesSubscription>() => T;
}

export interface EmitterPreviousValues {
  type?: EmitterType;
  pickupSite?: String;
  companyName?: String;
  companySiret?: String;
  companyAddress?: String;
  companyContact?: String;
  companyPhone?: Int;
  companyMail?: String;
}

export interface EmitterPreviousValuesPromise
  extends Promise<EmitterPreviousValues>,
    Fragmentable {
  type: () => Promise<EmitterType>;
  pickupSite: () => Promise<String>;
  companyName: () => Promise<String>;
  companySiret: () => Promise<String>;
  companyAddress: () => Promise<String>;
  companyContact: () => Promise<String>;
  companyPhone: () => Promise<Int>;
  companyMail: () => Promise<String>;
}

export interface EmitterPreviousValuesSubscription
  extends Promise<AsyncIterator<EmitterPreviousValues>>,
    Fragmentable {
  type: () => Promise<AsyncIterator<EmitterType>>;
  pickupSite: () => Promise<AsyncIterator<String>>;
  companyName: () => Promise<AsyncIterator<String>>;
  companySiret: () => Promise<AsyncIterator<String>>;
  companyAddress: () => Promise<AsyncIterator<String>>;
  companyContact: () => Promise<AsyncIterator<String>>;
  companyPhone: () => Promise<AsyncIterator<Int>>;
  companyMail: () => Promise<AsyncIterator<String>>;
}

export interface Transporter {
  companyName?: String;
  companySiret?: String;
  companyAddress?: String;
  companyContact?: String;
  companyPhone?: Int;
  companyMail?: String;
  receipt?: String;
  department?: String;
  validityLimit?: DateTimeOutput;
  contact?: String;
  numberPlate?: String;
}

export interface TransporterPromise extends Promise<Transporter>, Fragmentable {
  companyName: () => Promise<String>;
  companySiret: () => Promise<String>;
  companyAddress: () => Promise<String>;
  companyContact: () => Promise<String>;
  companyPhone: () => Promise<Int>;
  companyMail: () => Promise<String>;
  receipt: () => Promise<String>;
  department: () => Promise<String>;
  validityLimit: () => Promise<DateTimeOutput>;
  contact: () => Promise<String>;
  numberPlate: () => Promise<String>;
}

export interface TransporterSubscription
  extends Promise<AsyncIterator<Transporter>>,
    Fragmentable {
  companyName: () => Promise<AsyncIterator<String>>;
  companySiret: () => Promise<AsyncIterator<String>>;
  companyAddress: () => Promise<AsyncIterator<String>>;
  companyContact: () => Promise<AsyncIterator<String>>;
  companyPhone: () => Promise<AsyncIterator<Int>>;
  companyMail: () => Promise<AsyncIterator<String>>;
  receipt: () => Promise<AsyncIterator<String>>;
  department: () => Promise<AsyncIterator<String>>;
  validityLimit: () => Promise<AsyncIterator<DateTimeOutput>>;
  contact: () => Promise<AsyncIterator<String>>;
  numberPlate: () => Promise<AsyncIterator<String>>;
}

export interface CompanyEdge {
  cursor: String;
}

export interface CompanyEdgePromise extends Promise<CompanyEdge>, Fragmentable {
  node: <T = CompanyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CompanyEdgeSubscription
  extends Promise<AsyncIterator<CompanyEdge>>,
    Fragmentable {
  node: <T = CompanySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Company {
  siret: Int;
}

export interface CompanyPromise extends Promise<Company>, Fragmentable {
  siret: () => Promise<Int>;
}

export interface CompanySubscription
  extends Promise<AsyncIterator<Company>>,
    Fragmentable {
  siret: () => Promise<AsyncIterator<Int>>;
}

export interface FormSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface FormSubscriptionPayloadPromise
  extends Promise<FormSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FormPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FormPreviousValuesPromise>() => T;
}

export interface FormSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FormSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FormSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FormPreviousValuesSubscription>() => T;
}

export interface WasteDetailsConnection {}

export interface WasteDetailsConnectionPromise
  extends Promise<WasteDetailsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<WasteDetailsEdge>>() => T;
  aggregate: <T = AggregateWasteDetailsPromise>() => T;
}

export interface WasteDetailsConnectionSubscription
  extends Promise<AsyncIterator<WasteDetailsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<WasteDetailsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateWasteDetailsSubscription>() => T;
}

export interface FormPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface FormPreviousValuesPromise
  extends Promise<FormPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface FormPreviousValuesSubscription
  extends Promise<AsyncIterator<FormPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateTransporter {
  count: Int;
}

export interface AggregateTransporterPromise
  extends Promise<AggregateTransporter>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTransporterSubscription
  extends Promise<AsyncIterator<AggregateTransporter>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserPreviousValues {
  id: ID_Output;
  email: String;
  password: String;
  name?: String;
  phone?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  name: () => Promise<String>;
  phone: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface RecipientEdge {
  cursor: String;
}

export interface RecipientEdgePromise
  extends Promise<RecipientEdge>,
    Fragmentable {
  node: <T = RecipientPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RecipientEdgeSubscription
  extends Promise<AsyncIterator<RecipientEdge>>,
    Fragmentable {
  node: <T = RecipientSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface FormCompanySubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface FormCompanySubscriptionPayloadPromise
  extends Promise<FormCompanySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FormCompanyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FormCompanyPreviousValuesPromise>() => T;
}

export interface FormCompanySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FormCompanySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FormCompanySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FormCompanyPreviousValuesSubscription>() => T;
}

export interface FormCompanyConnection {}

export interface FormCompanyConnectionPromise
  extends Promise<FormCompanyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FormCompanyEdge>>() => T;
  aggregate: <T = AggregateFormCompanyPromise>() => T;
}

export interface FormCompanyConnectionSubscription
  extends Promise<AsyncIterator<FormCompanyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FormCompanyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFormCompanySubscription>() => T;
}

export interface FormCompanyPreviousValues {
  name?: String;
  siret?: String;
  address?: String;
  contact?: String;
  phone?: Int;
  mail?: String;
}

export interface FormCompanyPreviousValuesPromise
  extends Promise<FormCompanyPreviousValues>,
    Fragmentable {
  name: () => Promise<String>;
  siret: () => Promise<String>;
  address: () => Promise<String>;
  contact: () => Promise<String>;
  phone: () => Promise<Int>;
  mail: () => Promise<String>;
}

export interface FormCompanyPreviousValuesSubscription
  extends Promise<AsyncIterator<FormCompanyPreviousValues>>,
    Fragmentable {
  name: () => Promise<AsyncIterator<String>>;
  siret: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  contact: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<Int>>;
  mail: () => Promise<AsyncIterator<String>>;
}

export interface FormConnection {}

export interface FormConnectionPromise
  extends Promise<FormConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FormEdge>>() => T;
  aggregate: <T = AggregateFormPromise>() => T;
}

export interface FormConnectionSubscription
  extends Promise<AsyncIterator<FormConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FormEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFormSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface Recipient {
  cap?: String;
  processingOperation?: String;
  companyName?: String;
  companySiret?: String;
  companyAddress?: String;
  companyContact?: String;
  companyPhone?: Int;
  companyMail?: String;
}

export interface RecipientPromise extends Promise<Recipient>, Fragmentable {
  cap: () => Promise<String>;
  processingOperation: () => Promise<String>;
  companyName: () => Promise<String>;
  companySiret: () => Promise<String>;
  companyAddress: () => Promise<String>;
  companyContact: () => Promise<String>;
  companyPhone: () => Promise<Int>;
  companyMail: () => Promise<String>;
}

export interface RecipientSubscription
  extends Promise<AsyncIterator<Recipient>>,
    Fragmentable {
  cap: () => Promise<AsyncIterator<String>>;
  processingOperation: () => Promise<AsyncIterator<String>>;
  companyName: () => Promise<AsyncIterator<String>>;
  companySiret: () => Promise<AsyncIterator<String>>;
  companyAddress: () => Promise<AsyncIterator<String>>;
  companyContact: () => Promise<AsyncIterator<String>>;
  companyPhone: () => Promise<AsyncIterator<Int>>;
  companyMail: () => Promise<AsyncIterator<String>>;
}

export interface RecipientSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface RecipientSubscriptionPayloadPromise
  extends Promise<RecipientSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RecipientPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RecipientPreviousValuesPromise>() => T;
}

export interface RecipientSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RecipientSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RecipientSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RecipientPreviousValuesSubscription>() => T;
}

export interface UserEdge {
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TransporterPreviousValues {
  companyName?: String;
  companySiret?: String;
  companyAddress?: String;
  companyContact?: String;
  companyPhone?: Int;
  companyMail?: String;
  receipt?: String;
  department?: String;
  validityLimit?: DateTimeOutput;
  contact?: String;
  numberPlate?: String;
}

export interface TransporterPreviousValuesPromise
  extends Promise<TransporterPreviousValues>,
    Fragmentable {
  companyName: () => Promise<String>;
  companySiret: () => Promise<String>;
  companyAddress: () => Promise<String>;
  companyContact: () => Promise<String>;
  companyPhone: () => Promise<Int>;
  companyMail: () => Promise<String>;
  receipt: () => Promise<String>;
  department: () => Promise<String>;
  validityLimit: () => Promise<DateTimeOutput>;
  contact: () => Promise<String>;
  numberPlate: () => Promise<String>;
}

export interface TransporterPreviousValuesSubscription
  extends Promise<AsyncIterator<TransporterPreviousValues>>,
    Fragmentable {
  companyName: () => Promise<AsyncIterator<String>>;
  companySiret: () => Promise<AsyncIterator<String>>;
  companyAddress: () => Promise<AsyncIterator<String>>;
  companyContact: () => Promise<AsyncIterator<String>>;
  companyPhone: () => Promise<AsyncIterator<Int>>;
  companyMail: () => Promise<AsyncIterator<String>>;
  receipt: () => Promise<AsyncIterator<String>>;
  department: () => Promise<AsyncIterator<String>>;
  validityLimit: () => Promise<AsyncIterator<DateTimeOutput>>;
  contact: () => Promise<AsyncIterator<String>>;
  numberPlate: () => Promise<AsyncIterator<String>>;
}

export interface TransporterSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface TransporterSubscriptionPayloadPromise
  extends Promise<TransporterSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TransporterPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TransporterPreviousValuesPromise>() => T;
}

export interface TransporterSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TransporterSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TransporterSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TransporterPreviousValuesSubscription>() => T;
}

export interface CompanyConnection {}

export interface CompanyConnectionPromise
  extends Promise<CompanyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CompanyEdge>>() => T;
  aggregate: <T = AggregateCompanyPromise>() => T;
}

export interface CompanyConnectionSubscription
  extends Promise<AsyncIterator<CompanyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CompanyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCompanySubscription>() => T;
}

export interface RecipientPreviousValues {
  cap?: String;
  processingOperation?: String;
  companyName?: String;
  companySiret?: String;
  companyAddress?: String;
  companyContact?: String;
  companyPhone?: Int;
  companyMail?: String;
}

export interface RecipientPreviousValuesPromise
  extends Promise<RecipientPreviousValues>,
    Fragmentable {
  cap: () => Promise<String>;
  processingOperation: () => Promise<String>;
  companyName: () => Promise<String>;
  companySiret: () => Promise<String>;
  companyAddress: () => Promise<String>;
  companyContact: () => Promise<String>;
  companyPhone: () => Promise<Int>;
  companyMail: () => Promise<String>;
}

export interface RecipientPreviousValuesSubscription
  extends Promise<AsyncIterator<RecipientPreviousValues>>,
    Fragmentable {
  cap: () => Promise<AsyncIterator<String>>;
  processingOperation: () => Promise<AsyncIterator<String>>;
  companyName: () => Promise<AsyncIterator<String>>;
  companySiret: () => Promise<AsyncIterator<String>>;
  companyAddress: () => Promise<AsyncIterator<String>>;
  companyContact: () => Promise<AsyncIterator<String>>;
  companyPhone: () => Promise<AsyncIterator<Int>>;
  companyMail: () => Promise<AsyncIterator<String>>;
}

export interface TransporterConnection {}

export interface TransporterConnectionPromise
  extends Promise<TransporterConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TransporterEdge>>() => T;
  aggregate: <T = AggregateTransporterPromise>() => T;
}

export interface TransporterConnectionSubscription
  extends Promise<AsyncIterator<TransporterConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TransporterEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTransporterSubscription>() => T;
}

export interface AggregateWasteDetails {
  count: Int;
}

export interface AggregateWasteDetailsPromise
  extends Promise<AggregateWasteDetails>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateWasteDetailsSubscription
  extends Promise<AsyncIterator<AggregateWasteDetails>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface WasteDetails {
  code?: String;
  onuCode?: String;
  packaging?: String;
  numberOfPackages?: Int;
  quantity?: Float;
  quantityType?: QuantityType;
}

export interface WasteDetailsPromise
  extends Promise<WasteDetails>,
    Fragmentable {
  code: () => Promise<String>;
  onuCode: () => Promise<String>;
  packaging: () => Promise<String>;
  numberOfPackages: () => Promise<Int>;
  quantity: () => Promise<Float>;
  quantityType: () => Promise<QuantityType>;
}

export interface WasteDetailsSubscription
  extends Promise<AsyncIterator<WasteDetails>>,
    Fragmentable {
  code: () => Promise<AsyncIterator<String>>;
  onuCode: () => Promise<AsyncIterator<String>>;
  packaging: () => Promise<AsyncIterator<String>>;
  numberOfPackages: () => Promise<AsyncIterator<Int>>;
  quantity: () => Promise<AsyncIterator<Float>>;
  quantityType: () => Promise<AsyncIterator<QuantityType>>;
}

export interface AggregateForm {
  count: Int;
}

export interface AggregateFormPromise
  extends Promise<AggregateForm>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFormSubscription
  extends Promise<AsyncIterator<AggregateForm>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateFormCompany {
  count: Int;
}

export interface AggregateFormCompanyPromise
  extends Promise<AggregateFormCompany>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFormCompanySubscription
  extends Promise<AsyncIterator<AggregateFormCompany>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

export type Long = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/**
 * Model Metadata
 */

export const models = [
  {
    name: "Company",
    embedded: false
  },
  {
    name: "Emitter",
    embedded: false
  },
  {
    name: "EmitterType",
    embedded: false
  },
  {
    name: "Form",
    embedded: false
  },
  {
    name: "FormCompany",
    embedded: false
  },
  {
    name: "QuantityType",
    embedded: false
  },
  {
    name: "Recipient",
    embedded: false
  },
  {
    name: "Transporter",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "WasteDetails",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `http://localhost:4466`
});
export const prisma = new Prisma();
