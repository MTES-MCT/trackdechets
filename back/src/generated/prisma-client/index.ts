// Code generated by Prisma (prisma@1.22.0). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode, GraphQLSchema } from "graphql";
import { makePrismaClientClass, BaseClientOptions } from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  company: (where?: CompanyWhereInput) => Promise<boolean>;
  form: (where?: FormWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  userActivationHash: (
    where?: UserActivationHashWhereInput
  ) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  company: (where: CompanyWhereUniqueInput) => CompanyPromise;
  companies: (
    args?: {
      where?: CompanyWhereInput;
      orderBy?: CompanyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Company>;
  companiesConnection: (
    args?: {
      where?: CompanyWhereInput;
      orderBy?: CompanyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CompanyConnectionPromise;
  form: (where: FormWhereUniqueInput) => FormPromise;
  forms: (
    args?: {
      where?: FormWhereInput;
      orderBy?: FormOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Form>;
  formsConnection: (
    args?: {
      where?: FormWhereInput;
      orderBy?: FormOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FormConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  userActivationHash: (
    where: UserActivationHashWhereUniqueInput
  ) => UserActivationHashPromise;
  userActivationHashes: (
    args?: {
      where?: UserActivationHashWhereInput;
      orderBy?: UserActivationHashOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<UserActivationHash>;
  userActivationHashesConnection: (
    args?: {
      where?: UserActivationHashWhereInput;
      orderBy?: UserActivationHashOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserActivationHashConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCompany: (data: CompanyCreateInput) => CompanyPromise;
  updateCompany: (
    args: { data: CompanyUpdateInput; where: CompanyWhereUniqueInput }
  ) => CompanyPromise;
  updateManyCompanies: (
    args: { data: CompanyUpdateManyMutationInput; where?: CompanyWhereInput }
  ) => BatchPayloadPromise;
  upsertCompany: (
    args: {
      where: CompanyWhereUniqueInput;
      create: CompanyCreateInput;
      update: CompanyUpdateInput;
    }
  ) => CompanyPromise;
  deleteCompany: (where: CompanyWhereUniqueInput) => CompanyPromise;
  deleteManyCompanies: (where?: CompanyWhereInput) => BatchPayloadPromise;
  createForm: (data: FormCreateInput) => FormPromise;
  updateForm: (
    args: { data: FormUpdateInput; where: FormWhereUniqueInput }
  ) => FormPromise;
  updateManyForms: (
    args: { data: FormUpdateManyMutationInput; where?: FormWhereInput }
  ) => BatchPayloadPromise;
  upsertForm: (
    args: {
      where: FormWhereUniqueInput;
      create: FormCreateInput;
      update: FormUpdateInput;
    }
  ) => FormPromise;
  deleteForm: (where: FormWhereUniqueInput) => FormPromise;
  deleteManyForms: (where?: FormWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createUserActivationHash: (
    data: UserActivationHashCreateInput
  ) => UserActivationHashPromise;
  updateUserActivationHash: (
    args: {
      data: UserActivationHashUpdateInput;
      where: UserActivationHashWhereUniqueInput;
    }
  ) => UserActivationHashPromise;
  updateManyUserActivationHashes: (
    args: {
      data: UserActivationHashUpdateManyMutationInput;
      where?: UserActivationHashWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertUserActivationHash: (
    args: {
      where: UserActivationHashWhereUniqueInput;
      create: UserActivationHashCreateInput;
      update: UserActivationHashUpdateInput;
    }
  ) => UserActivationHashPromise;
  deleteUserActivationHash: (
    where: UserActivationHashWhereUniqueInput
  ) => UserActivationHashPromise;
  deleteManyUserActivationHashes: (
    where?: UserActivationHashWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  company: (
    where?: CompanySubscriptionWhereInput
  ) => CompanySubscriptionPayloadSubscription;
  form: (
    where?: FormSubscriptionWhereInput
  ) => FormSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  userActivationHash: (
    where?: UserActivationHashSubscriptionWhereInput
  ) => UserActivationHashSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type EmitterType = "PRODUCER" | "OTHER";

export type QuantityType = "REAL" | "ESTIMATED";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type FormOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "readableId_ASC"
  | "readableId_DESC"
  | "isDeleted_ASC"
  | "isDeleted_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "status_ASC"
  | "status_DESC"
  | "sentAt_ASC"
  | "sentAt_DESC"
  | "sentBy_ASC"
  | "sentBy_DESC"
  | "isAccepted_ASC"
  | "isAccepted_DESC"
  | "receivedBy_ASC"
  | "receivedBy_DESC"
  | "receivedAt_ASC"
  | "receivedAt_DESC"
  | "quantityReceived_ASC"
  | "quantityReceived_DESC"
  | "processingOperationDone_ASC"
  | "processingOperationDone_DESC"
  | "emitterType_ASC"
  | "emitterType_DESC"
  | "emitterPickupSite_ASC"
  | "emitterPickupSite_DESC"
  | "emitterCompanyName_ASC"
  | "emitterCompanyName_DESC"
  | "emitterCompanySiret_ASC"
  | "emitterCompanySiret_DESC"
  | "emitterCompanyAddress_ASC"
  | "emitterCompanyAddress_DESC"
  | "emitterCompanyContact_ASC"
  | "emitterCompanyContact_DESC"
  | "emitterCompanyPhone_ASC"
  | "emitterCompanyPhone_DESC"
  | "emitterCompanyMail_ASC"
  | "emitterCompanyMail_DESC"
  | "recipientCap_ASC"
  | "recipientCap_DESC"
  | "recipientProcessingOperation_ASC"
  | "recipientProcessingOperation_DESC"
  | "recipientCompanyName_ASC"
  | "recipientCompanyName_DESC"
  | "recipientCompanySiret_ASC"
  | "recipientCompanySiret_DESC"
  | "recipientCompanyAddress_ASC"
  | "recipientCompanyAddress_DESC"
  | "recipientCompanyContact_ASC"
  | "recipientCompanyContact_DESC"
  | "recipientCompanyPhone_ASC"
  | "recipientCompanyPhone_DESC"
  | "recipientCompanyMail_ASC"
  | "recipientCompanyMail_DESC"
  | "transporterCompanyName_ASC"
  | "transporterCompanyName_DESC"
  | "transporterCompanySiret_ASC"
  | "transporterCompanySiret_DESC"
  | "transporterCompanyAddress_ASC"
  | "transporterCompanyAddress_DESC"
  | "transporterCompanyContact_ASC"
  | "transporterCompanyContact_DESC"
  | "transporterCompanyPhone_ASC"
  | "transporterCompanyPhone_DESC"
  | "transporterCompanyMail_ASC"
  | "transporterCompanyMail_DESC"
  | "transporterReceipt_ASC"
  | "transporterReceipt_DESC"
  | "transporterDepartment_ASC"
  | "transporterDepartment_DESC"
  | "transporterValidityLimit_ASC"
  | "transporterValidityLimit_DESC"
  | "transporterContact_ASC"
  | "transporterContact_DESC"
  | "transporterNumberPlate_ASC"
  | "transporterNumberPlate_DESC"
  | "wasteDetailsCode_ASC"
  | "wasteDetailsCode_DESC"
  | "wasteDetailsName_ASC"
  | "wasteDetailsName_DESC"
  | "wasteDetailsOnuCode_ASC"
  | "wasteDetailsOnuCode_DESC"
  | "wasteDetailsPackagings_ASC"
  | "wasteDetailsPackagings_DESC"
  | "wasteDetailsOtherPackaging_ASC"
  | "wasteDetailsOtherPackaging_DESC"
  | "wasteDetailsNumberOfPackages_ASC"
  | "wasteDetailsNumberOfPackages_DESC"
  | "wasteDetailsQuantity_ASC"
  | "wasteDetailsQuantity_DESC"
  | "wasteDetailsQuantityType_ASC"
  | "wasteDetailsQuantityType_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "isActive_ASC"
  | "isActive_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "name_ASC"
  | "name_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "userType_ASC"
  | "userType_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CompanyOrderByInput =
  | "siret_ASC"
  | "siret_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserActivationHashOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "hash_ASC"
  | "hash_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  isActive?: Boolean;
  isActive_not?: Boolean;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  phone?: String;
  phone_not?: String;
  phone_in?: String[] | String;
  phone_not_in?: String[] | String;
  phone_lt?: String;
  phone_lte?: String;
  phone_gt?: String;
  phone_gte?: String;
  phone_contains?: String;
  phone_not_contains?: String;
  phone_starts_with?: String;
  phone_not_starts_with?: String;
  phone_ends_with?: String;
  phone_not_ends_with?: String;
  company?: CompanyWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface CompanyUpdateInput {
  siret?: String;
}

export interface UserUpdateDataInput {
  isActive?: Boolean;
  email?: String;
  password?: String;
  name?: String;
  phone?: String;
  company?: CompanyUpdateOneRequiredInput;
  userType?: Json;
}

export type CompanyWhereUniqueInput = AtLeastOne<{
  siret: String;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
}>;

export interface UserActivationHashUpdateInput {
  user?: UserUpdateOneRequiredInput;
  hash?: String;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface UserActivationHashCreateInput {
  user: UserCreateOneInput;
  hash: String;
}

export interface UserUpdateOneRequiredInput {
  create?: UserCreateInput;
  update?: UserUpdateDataInput;
  upsert?: UserUpsertNestedInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateInput {
  isActive?: Boolean;
  email?: String;
  password?: String;
  name?: String;
  phone?: String;
  company?: CompanyUpdateOneRequiredInput;
  userType?: Json;
}

export interface FormUpdateInput {
  readableId?: String;
  isDeleted?: Boolean;
  owner?: UserUpdateOneRequiredInput;
  status?: String;
  sentAt?: DateTimeInput;
  sentBy?: String;
  isAccepted?: Boolean;
  receivedBy?: String;
  receivedAt?: DateTimeInput;
  quantityReceived?: Float;
  processingOperationDone?: String;
  emitterType?: EmitterType;
  emitterPickupSite?: String;
  emitterCompanyName?: String;
  emitterCompanySiret?: String;
  emitterCompanyAddress?: String;
  emitterCompanyContact?: String;
  emitterCompanyPhone?: String;
  emitterCompanyMail?: String;
  recipientCap?: String;
  recipientProcessingOperation?: String;
  recipientCompanyName?: String;
  recipientCompanySiret?: String;
  recipientCompanyAddress?: String;
  recipientCompanyContact?: String;
  recipientCompanyPhone?: String;
  recipientCompanyMail?: String;
  transporterCompanyName?: String;
  transporterCompanySiret?: String;
  transporterCompanyAddress?: String;
  transporterCompanyContact?: String;
  transporterCompanyPhone?: String;
  transporterCompanyMail?: String;
  transporterReceipt?: String;
  transporterDepartment?: String;
  transporterValidityLimit?: DateTimeInput;
  transporterContact?: String;
  transporterNumberPlate?: String;
  wasteDetailsCode?: String;
  wasteDetailsName?: String;
  wasteDetailsOnuCode?: String;
  wasteDetailsPackagings?: Json;
  wasteDetailsOtherPackaging?: String;
  wasteDetailsNumberOfPackages?: Int;
  wasteDetailsQuantity?: Float;
  wasteDetailsQuantityType?: QuantityType;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface CompanyCreateOneInput {
  create?: CompanyCreateInput;
  connect?: CompanyWhereUniqueInput;
}

export interface UserActivationHashUpdateManyMutationInput {
  hash?: String;
}

export type UserActivationHashWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  hash?: String;
}>;

export interface FormWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  readableId?: String;
  readableId_not?: String;
  readableId_in?: String[] | String;
  readableId_not_in?: String[] | String;
  readableId_lt?: String;
  readableId_lte?: String;
  readableId_gt?: String;
  readableId_gte?: String;
  readableId_contains?: String;
  readableId_not_contains?: String;
  readableId_starts_with?: String;
  readableId_not_starts_with?: String;
  readableId_ends_with?: String;
  readableId_not_ends_with?: String;
  isDeleted?: Boolean;
  isDeleted_not?: Boolean;
  owner?: UserWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  status?: String;
  status_not?: String;
  status_in?: String[] | String;
  status_not_in?: String[] | String;
  status_lt?: String;
  status_lte?: String;
  status_gt?: String;
  status_gte?: String;
  status_contains?: String;
  status_not_contains?: String;
  status_starts_with?: String;
  status_not_starts_with?: String;
  status_ends_with?: String;
  status_not_ends_with?: String;
  sentAt?: DateTimeInput;
  sentAt_not?: DateTimeInput;
  sentAt_in?: DateTimeInput[] | DateTimeInput;
  sentAt_not_in?: DateTimeInput[] | DateTimeInput;
  sentAt_lt?: DateTimeInput;
  sentAt_lte?: DateTimeInput;
  sentAt_gt?: DateTimeInput;
  sentAt_gte?: DateTimeInput;
  sentBy?: String;
  sentBy_not?: String;
  sentBy_in?: String[] | String;
  sentBy_not_in?: String[] | String;
  sentBy_lt?: String;
  sentBy_lte?: String;
  sentBy_gt?: String;
  sentBy_gte?: String;
  sentBy_contains?: String;
  sentBy_not_contains?: String;
  sentBy_starts_with?: String;
  sentBy_not_starts_with?: String;
  sentBy_ends_with?: String;
  sentBy_not_ends_with?: String;
  isAccepted?: Boolean;
  isAccepted_not?: Boolean;
  receivedBy?: String;
  receivedBy_not?: String;
  receivedBy_in?: String[] | String;
  receivedBy_not_in?: String[] | String;
  receivedBy_lt?: String;
  receivedBy_lte?: String;
  receivedBy_gt?: String;
  receivedBy_gte?: String;
  receivedBy_contains?: String;
  receivedBy_not_contains?: String;
  receivedBy_starts_with?: String;
  receivedBy_not_starts_with?: String;
  receivedBy_ends_with?: String;
  receivedBy_not_ends_with?: String;
  receivedAt?: DateTimeInput;
  receivedAt_not?: DateTimeInput;
  receivedAt_in?: DateTimeInput[] | DateTimeInput;
  receivedAt_not_in?: DateTimeInput[] | DateTimeInput;
  receivedAt_lt?: DateTimeInput;
  receivedAt_lte?: DateTimeInput;
  receivedAt_gt?: DateTimeInput;
  receivedAt_gte?: DateTimeInput;
  quantityReceived?: Float;
  quantityReceived_not?: Float;
  quantityReceived_in?: Float[] | Float;
  quantityReceived_not_in?: Float[] | Float;
  quantityReceived_lt?: Float;
  quantityReceived_lte?: Float;
  quantityReceived_gt?: Float;
  quantityReceived_gte?: Float;
  processingOperationDone?: String;
  processingOperationDone_not?: String;
  processingOperationDone_in?: String[] | String;
  processingOperationDone_not_in?: String[] | String;
  processingOperationDone_lt?: String;
  processingOperationDone_lte?: String;
  processingOperationDone_gt?: String;
  processingOperationDone_gte?: String;
  processingOperationDone_contains?: String;
  processingOperationDone_not_contains?: String;
  processingOperationDone_starts_with?: String;
  processingOperationDone_not_starts_with?: String;
  processingOperationDone_ends_with?: String;
  processingOperationDone_not_ends_with?: String;
  emitterType?: EmitterType;
  emitterType_not?: EmitterType;
  emitterType_in?: EmitterType[] | EmitterType;
  emitterType_not_in?: EmitterType[] | EmitterType;
  emitterPickupSite?: String;
  emitterPickupSite_not?: String;
  emitterPickupSite_in?: String[] | String;
  emitterPickupSite_not_in?: String[] | String;
  emitterPickupSite_lt?: String;
  emitterPickupSite_lte?: String;
  emitterPickupSite_gt?: String;
  emitterPickupSite_gte?: String;
  emitterPickupSite_contains?: String;
  emitterPickupSite_not_contains?: String;
  emitterPickupSite_starts_with?: String;
  emitterPickupSite_not_starts_with?: String;
  emitterPickupSite_ends_with?: String;
  emitterPickupSite_not_ends_with?: String;
  emitterCompanyName?: String;
  emitterCompanyName_not?: String;
  emitterCompanyName_in?: String[] | String;
  emitterCompanyName_not_in?: String[] | String;
  emitterCompanyName_lt?: String;
  emitterCompanyName_lte?: String;
  emitterCompanyName_gt?: String;
  emitterCompanyName_gte?: String;
  emitterCompanyName_contains?: String;
  emitterCompanyName_not_contains?: String;
  emitterCompanyName_starts_with?: String;
  emitterCompanyName_not_starts_with?: String;
  emitterCompanyName_ends_with?: String;
  emitterCompanyName_not_ends_with?: String;
  emitterCompanySiret?: String;
  emitterCompanySiret_not?: String;
  emitterCompanySiret_in?: String[] | String;
  emitterCompanySiret_not_in?: String[] | String;
  emitterCompanySiret_lt?: String;
  emitterCompanySiret_lte?: String;
  emitterCompanySiret_gt?: String;
  emitterCompanySiret_gte?: String;
  emitterCompanySiret_contains?: String;
  emitterCompanySiret_not_contains?: String;
  emitterCompanySiret_starts_with?: String;
  emitterCompanySiret_not_starts_with?: String;
  emitterCompanySiret_ends_with?: String;
  emitterCompanySiret_not_ends_with?: String;
  emitterCompanyAddress?: String;
  emitterCompanyAddress_not?: String;
  emitterCompanyAddress_in?: String[] | String;
  emitterCompanyAddress_not_in?: String[] | String;
  emitterCompanyAddress_lt?: String;
  emitterCompanyAddress_lte?: String;
  emitterCompanyAddress_gt?: String;
  emitterCompanyAddress_gte?: String;
  emitterCompanyAddress_contains?: String;
  emitterCompanyAddress_not_contains?: String;
  emitterCompanyAddress_starts_with?: String;
  emitterCompanyAddress_not_starts_with?: String;
  emitterCompanyAddress_ends_with?: String;
  emitterCompanyAddress_not_ends_with?: String;
  emitterCompanyContact?: String;
  emitterCompanyContact_not?: String;
  emitterCompanyContact_in?: String[] | String;
  emitterCompanyContact_not_in?: String[] | String;
  emitterCompanyContact_lt?: String;
  emitterCompanyContact_lte?: String;
  emitterCompanyContact_gt?: String;
  emitterCompanyContact_gte?: String;
  emitterCompanyContact_contains?: String;
  emitterCompanyContact_not_contains?: String;
  emitterCompanyContact_starts_with?: String;
  emitterCompanyContact_not_starts_with?: String;
  emitterCompanyContact_ends_with?: String;
  emitterCompanyContact_not_ends_with?: String;
  emitterCompanyPhone?: String;
  emitterCompanyPhone_not?: String;
  emitterCompanyPhone_in?: String[] | String;
  emitterCompanyPhone_not_in?: String[] | String;
  emitterCompanyPhone_lt?: String;
  emitterCompanyPhone_lte?: String;
  emitterCompanyPhone_gt?: String;
  emitterCompanyPhone_gte?: String;
  emitterCompanyPhone_contains?: String;
  emitterCompanyPhone_not_contains?: String;
  emitterCompanyPhone_starts_with?: String;
  emitterCompanyPhone_not_starts_with?: String;
  emitterCompanyPhone_ends_with?: String;
  emitterCompanyPhone_not_ends_with?: String;
  emitterCompanyMail?: String;
  emitterCompanyMail_not?: String;
  emitterCompanyMail_in?: String[] | String;
  emitterCompanyMail_not_in?: String[] | String;
  emitterCompanyMail_lt?: String;
  emitterCompanyMail_lte?: String;
  emitterCompanyMail_gt?: String;
  emitterCompanyMail_gte?: String;
  emitterCompanyMail_contains?: String;
  emitterCompanyMail_not_contains?: String;
  emitterCompanyMail_starts_with?: String;
  emitterCompanyMail_not_starts_with?: String;
  emitterCompanyMail_ends_with?: String;
  emitterCompanyMail_not_ends_with?: String;
  recipientCap?: String;
  recipientCap_not?: String;
  recipientCap_in?: String[] | String;
  recipientCap_not_in?: String[] | String;
  recipientCap_lt?: String;
  recipientCap_lte?: String;
  recipientCap_gt?: String;
  recipientCap_gte?: String;
  recipientCap_contains?: String;
  recipientCap_not_contains?: String;
  recipientCap_starts_with?: String;
  recipientCap_not_starts_with?: String;
  recipientCap_ends_with?: String;
  recipientCap_not_ends_with?: String;
  recipientProcessingOperation?: String;
  recipientProcessingOperation_not?: String;
  recipientProcessingOperation_in?: String[] | String;
  recipientProcessingOperation_not_in?: String[] | String;
  recipientProcessingOperation_lt?: String;
  recipientProcessingOperation_lte?: String;
  recipientProcessingOperation_gt?: String;
  recipientProcessingOperation_gte?: String;
  recipientProcessingOperation_contains?: String;
  recipientProcessingOperation_not_contains?: String;
  recipientProcessingOperation_starts_with?: String;
  recipientProcessingOperation_not_starts_with?: String;
  recipientProcessingOperation_ends_with?: String;
  recipientProcessingOperation_not_ends_with?: String;
  recipientCompanyName?: String;
  recipientCompanyName_not?: String;
  recipientCompanyName_in?: String[] | String;
  recipientCompanyName_not_in?: String[] | String;
  recipientCompanyName_lt?: String;
  recipientCompanyName_lte?: String;
  recipientCompanyName_gt?: String;
  recipientCompanyName_gte?: String;
  recipientCompanyName_contains?: String;
  recipientCompanyName_not_contains?: String;
  recipientCompanyName_starts_with?: String;
  recipientCompanyName_not_starts_with?: String;
  recipientCompanyName_ends_with?: String;
  recipientCompanyName_not_ends_with?: String;
  recipientCompanySiret?: String;
  recipientCompanySiret_not?: String;
  recipientCompanySiret_in?: String[] | String;
  recipientCompanySiret_not_in?: String[] | String;
  recipientCompanySiret_lt?: String;
  recipientCompanySiret_lte?: String;
  recipientCompanySiret_gt?: String;
  recipientCompanySiret_gte?: String;
  recipientCompanySiret_contains?: String;
  recipientCompanySiret_not_contains?: String;
  recipientCompanySiret_starts_with?: String;
  recipientCompanySiret_not_starts_with?: String;
  recipientCompanySiret_ends_with?: String;
  recipientCompanySiret_not_ends_with?: String;
  recipientCompanyAddress?: String;
  recipientCompanyAddress_not?: String;
  recipientCompanyAddress_in?: String[] | String;
  recipientCompanyAddress_not_in?: String[] | String;
  recipientCompanyAddress_lt?: String;
  recipientCompanyAddress_lte?: String;
  recipientCompanyAddress_gt?: String;
  recipientCompanyAddress_gte?: String;
  recipientCompanyAddress_contains?: String;
  recipientCompanyAddress_not_contains?: String;
  recipientCompanyAddress_starts_with?: String;
  recipientCompanyAddress_not_starts_with?: String;
  recipientCompanyAddress_ends_with?: String;
  recipientCompanyAddress_not_ends_with?: String;
  recipientCompanyContact?: String;
  recipientCompanyContact_not?: String;
  recipientCompanyContact_in?: String[] | String;
  recipientCompanyContact_not_in?: String[] | String;
  recipientCompanyContact_lt?: String;
  recipientCompanyContact_lte?: String;
  recipientCompanyContact_gt?: String;
  recipientCompanyContact_gte?: String;
  recipientCompanyContact_contains?: String;
  recipientCompanyContact_not_contains?: String;
  recipientCompanyContact_starts_with?: String;
  recipientCompanyContact_not_starts_with?: String;
  recipientCompanyContact_ends_with?: String;
  recipientCompanyContact_not_ends_with?: String;
  recipientCompanyPhone?: String;
  recipientCompanyPhone_not?: String;
  recipientCompanyPhone_in?: String[] | String;
  recipientCompanyPhone_not_in?: String[] | String;
  recipientCompanyPhone_lt?: String;
  recipientCompanyPhone_lte?: String;
  recipientCompanyPhone_gt?: String;
  recipientCompanyPhone_gte?: String;
  recipientCompanyPhone_contains?: String;
  recipientCompanyPhone_not_contains?: String;
  recipientCompanyPhone_starts_with?: String;
  recipientCompanyPhone_not_starts_with?: String;
  recipientCompanyPhone_ends_with?: String;
  recipientCompanyPhone_not_ends_with?: String;
  recipientCompanyMail?: String;
  recipientCompanyMail_not?: String;
  recipientCompanyMail_in?: String[] | String;
  recipientCompanyMail_not_in?: String[] | String;
  recipientCompanyMail_lt?: String;
  recipientCompanyMail_lte?: String;
  recipientCompanyMail_gt?: String;
  recipientCompanyMail_gte?: String;
  recipientCompanyMail_contains?: String;
  recipientCompanyMail_not_contains?: String;
  recipientCompanyMail_starts_with?: String;
  recipientCompanyMail_not_starts_with?: String;
  recipientCompanyMail_ends_with?: String;
  recipientCompanyMail_not_ends_with?: String;
  transporterCompanyName?: String;
  transporterCompanyName_not?: String;
  transporterCompanyName_in?: String[] | String;
  transporterCompanyName_not_in?: String[] | String;
  transporterCompanyName_lt?: String;
  transporterCompanyName_lte?: String;
  transporterCompanyName_gt?: String;
  transporterCompanyName_gte?: String;
  transporterCompanyName_contains?: String;
  transporterCompanyName_not_contains?: String;
  transporterCompanyName_starts_with?: String;
  transporterCompanyName_not_starts_with?: String;
  transporterCompanyName_ends_with?: String;
  transporterCompanyName_not_ends_with?: String;
  transporterCompanySiret?: String;
  transporterCompanySiret_not?: String;
  transporterCompanySiret_in?: String[] | String;
  transporterCompanySiret_not_in?: String[] | String;
  transporterCompanySiret_lt?: String;
  transporterCompanySiret_lte?: String;
  transporterCompanySiret_gt?: String;
  transporterCompanySiret_gte?: String;
  transporterCompanySiret_contains?: String;
  transporterCompanySiret_not_contains?: String;
  transporterCompanySiret_starts_with?: String;
  transporterCompanySiret_not_starts_with?: String;
  transporterCompanySiret_ends_with?: String;
  transporterCompanySiret_not_ends_with?: String;
  transporterCompanyAddress?: String;
  transporterCompanyAddress_not?: String;
  transporterCompanyAddress_in?: String[] | String;
  transporterCompanyAddress_not_in?: String[] | String;
  transporterCompanyAddress_lt?: String;
  transporterCompanyAddress_lte?: String;
  transporterCompanyAddress_gt?: String;
  transporterCompanyAddress_gte?: String;
  transporterCompanyAddress_contains?: String;
  transporterCompanyAddress_not_contains?: String;
  transporterCompanyAddress_starts_with?: String;
  transporterCompanyAddress_not_starts_with?: String;
  transporterCompanyAddress_ends_with?: String;
  transporterCompanyAddress_not_ends_with?: String;
  transporterCompanyContact?: String;
  transporterCompanyContact_not?: String;
  transporterCompanyContact_in?: String[] | String;
  transporterCompanyContact_not_in?: String[] | String;
  transporterCompanyContact_lt?: String;
  transporterCompanyContact_lte?: String;
  transporterCompanyContact_gt?: String;
  transporterCompanyContact_gte?: String;
  transporterCompanyContact_contains?: String;
  transporterCompanyContact_not_contains?: String;
  transporterCompanyContact_starts_with?: String;
  transporterCompanyContact_not_starts_with?: String;
  transporterCompanyContact_ends_with?: String;
  transporterCompanyContact_not_ends_with?: String;
  transporterCompanyPhone?: String;
  transporterCompanyPhone_not?: String;
  transporterCompanyPhone_in?: String[] | String;
  transporterCompanyPhone_not_in?: String[] | String;
  transporterCompanyPhone_lt?: String;
  transporterCompanyPhone_lte?: String;
  transporterCompanyPhone_gt?: String;
  transporterCompanyPhone_gte?: String;
  transporterCompanyPhone_contains?: String;
  transporterCompanyPhone_not_contains?: String;
  transporterCompanyPhone_starts_with?: String;
  transporterCompanyPhone_not_starts_with?: String;
  transporterCompanyPhone_ends_with?: String;
  transporterCompanyPhone_not_ends_with?: String;
  transporterCompanyMail?: String;
  transporterCompanyMail_not?: String;
  transporterCompanyMail_in?: String[] | String;
  transporterCompanyMail_not_in?: String[] | String;
  transporterCompanyMail_lt?: String;
  transporterCompanyMail_lte?: String;
  transporterCompanyMail_gt?: String;
  transporterCompanyMail_gte?: String;
  transporterCompanyMail_contains?: String;
  transporterCompanyMail_not_contains?: String;
  transporterCompanyMail_starts_with?: String;
  transporterCompanyMail_not_starts_with?: String;
  transporterCompanyMail_ends_with?: String;
  transporterCompanyMail_not_ends_with?: String;
  transporterReceipt?: String;
  transporterReceipt_not?: String;
  transporterReceipt_in?: String[] | String;
  transporterReceipt_not_in?: String[] | String;
  transporterReceipt_lt?: String;
  transporterReceipt_lte?: String;
  transporterReceipt_gt?: String;
  transporterReceipt_gte?: String;
  transporterReceipt_contains?: String;
  transporterReceipt_not_contains?: String;
  transporterReceipt_starts_with?: String;
  transporterReceipt_not_starts_with?: String;
  transporterReceipt_ends_with?: String;
  transporterReceipt_not_ends_with?: String;
  transporterDepartment?: String;
  transporterDepartment_not?: String;
  transporterDepartment_in?: String[] | String;
  transporterDepartment_not_in?: String[] | String;
  transporterDepartment_lt?: String;
  transporterDepartment_lte?: String;
  transporterDepartment_gt?: String;
  transporterDepartment_gte?: String;
  transporterDepartment_contains?: String;
  transporterDepartment_not_contains?: String;
  transporterDepartment_starts_with?: String;
  transporterDepartment_not_starts_with?: String;
  transporterDepartment_ends_with?: String;
  transporterDepartment_not_ends_with?: String;
  transporterValidityLimit?: DateTimeInput;
  transporterValidityLimit_not?: DateTimeInput;
  transporterValidityLimit_in?: DateTimeInput[] | DateTimeInput;
  transporterValidityLimit_not_in?: DateTimeInput[] | DateTimeInput;
  transporterValidityLimit_lt?: DateTimeInput;
  transporterValidityLimit_lte?: DateTimeInput;
  transporterValidityLimit_gt?: DateTimeInput;
  transporterValidityLimit_gte?: DateTimeInput;
  transporterContact?: String;
  transporterContact_not?: String;
  transporterContact_in?: String[] | String;
  transporterContact_not_in?: String[] | String;
  transporterContact_lt?: String;
  transporterContact_lte?: String;
  transporterContact_gt?: String;
  transporterContact_gte?: String;
  transporterContact_contains?: String;
  transporterContact_not_contains?: String;
  transporterContact_starts_with?: String;
  transporterContact_not_starts_with?: String;
  transporterContact_ends_with?: String;
  transporterContact_not_ends_with?: String;
  transporterNumberPlate?: String;
  transporterNumberPlate_not?: String;
  transporterNumberPlate_in?: String[] | String;
  transporterNumberPlate_not_in?: String[] | String;
  transporterNumberPlate_lt?: String;
  transporterNumberPlate_lte?: String;
  transporterNumberPlate_gt?: String;
  transporterNumberPlate_gte?: String;
  transporterNumberPlate_contains?: String;
  transporterNumberPlate_not_contains?: String;
  transporterNumberPlate_starts_with?: String;
  transporterNumberPlate_not_starts_with?: String;
  transporterNumberPlate_ends_with?: String;
  transporterNumberPlate_not_ends_with?: String;
  wasteDetailsCode?: String;
  wasteDetailsCode_not?: String;
  wasteDetailsCode_in?: String[] | String;
  wasteDetailsCode_not_in?: String[] | String;
  wasteDetailsCode_lt?: String;
  wasteDetailsCode_lte?: String;
  wasteDetailsCode_gt?: String;
  wasteDetailsCode_gte?: String;
  wasteDetailsCode_contains?: String;
  wasteDetailsCode_not_contains?: String;
  wasteDetailsCode_starts_with?: String;
  wasteDetailsCode_not_starts_with?: String;
  wasteDetailsCode_ends_with?: String;
  wasteDetailsCode_not_ends_with?: String;
  wasteDetailsName?: String;
  wasteDetailsName_not?: String;
  wasteDetailsName_in?: String[] | String;
  wasteDetailsName_not_in?: String[] | String;
  wasteDetailsName_lt?: String;
  wasteDetailsName_lte?: String;
  wasteDetailsName_gt?: String;
  wasteDetailsName_gte?: String;
  wasteDetailsName_contains?: String;
  wasteDetailsName_not_contains?: String;
  wasteDetailsName_starts_with?: String;
  wasteDetailsName_not_starts_with?: String;
  wasteDetailsName_ends_with?: String;
  wasteDetailsName_not_ends_with?: String;
  wasteDetailsOnuCode?: String;
  wasteDetailsOnuCode_not?: String;
  wasteDetailsOnuCode_in?: String[] | String;
  wasteDetailsOnuCode_not_in?: String[] | String;
  wasteDetailsOnuCode_lt?: String;
  wasteDetailsOnuCode_lte?: String;
  wasteDetailsOnuCode_gt?: String;
  wasteDetailsOnuCode_gte?: String;
  wasteDetailsOnuCode_contains?: String;
  wasteDetailsOnuCode_not_contains?: String;
  wasteDetailsOnuCode_starts_with?: String;
  wasteDetailsOnuCode_not_starts_with?: String;
  wasteDetailsOnuCode_ends_with?: String;
  wasteDetailsOnuCode_not_ends_with?: String;
  wasteDetailsOtherPackaging?: String;
  wasteDetailsOtherPackaging_not?: String;
  wasteDetailsOtherPackaging_in?: String[] | String;
  wasteDetailsOtherPackaging_not_in?: String[] | String;
  wasteDetailsOtherPackaging_lt?: String;
  wasteDetailsOtherPackaging_lte?: String;
  wasteDetailsOtherPackaging_gt?: String;
  wasteDetailsOtherPackaging_gte?: String;
  wasteDetailsOtherPackaging_contains?: String;
  wasteDetailsOtherPackaging_not_contains?: String;
  wasteDetailsOtherPackaging_starts_with?: String;
  wasteDetailsOtherPackaging_not_starts_with?: String;
  wasteDetailsOtherPackaging_ends_with?: String;
  wasteDetailsOtherPackaging_not_ends_with?: String;
  wasteDetailsNumberOfPackages?: Int;
  wasteDetailsNumberOfPackages_not?: Int;
  wasteDetailsNumberOfPackages_in?: Int[] | Int;
  wasteDetailsNumberOfPackages_not_in?: Int[] | Int;
  wasteDetailsNumberOfPackages_lt?: Int;
  wasteDetailsNumberOfPackages_lte?: Int;
  wasteDetailsNumberOfPackages_gt?: Int;
  wasteDetailsNumberOfPackages_gte?: Int;
  wasteDetailsQuantity?: Float;
  wasteDetailsQuantity_not?: Float;
  wasteDetailsQuantity_in?: Float[] | Float;
  wasteDetailsQuantity_not_in?: Float[] | Float;
  wasteDetailsQuantity_lt?: Float;
  wasteDetailsQuantity_lte?: Float;
  wasteDetailsQuantity_gt?: Float;
  wasteDetailsQuantity_gte?: Float;
  wasteDetailsQuantityType?: QuantityType;
  wasteDetailsQuantityType_not?: QuantityType;
  wasteDetailsQuantityType_in?: QuantityType[] | QuantityType;
  wasteDetailsQuantityType_not_in?: QuantityType[] | QuantityType;
  AND?: FormWhereInput[] | FormWhereInput;
  OR?: FormWhereInput[] | FormWhereInput;
  NOT?: FormWhereInput[] | FormWhereInput;
}

export interface UserCreateInput {
  isActive?: Boolean;
  email: String;
  password: String;
  name?: String;
  phone?: String;
  company: CompanyCreateOneInput;
  userType?: Json;
}

export interface FormSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: FormWhereInput;
  AND?: FormSubscriptionWhereInput[] | FormSubscriptionWhereInput;
  OR?: FormSubscriptionWhereInput[] | FormSubscriptionWhereInput;
  NOT?: FormSubscriptionWhereInput[] | FormSubscriptionWhereInput;
}

export interface UserActivationHashWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  user?: UserWhereInput;
  hash?: String;
  hash_not?: String;
  hash_in?: String[] | String;
  hash_not_in?: String[] | String;
  hash_lt?: String;
  hash_lte?: String;
  hash_gt?: String;
  hash_gte?: String;
  hash_contains?: String;
  hash_not_contains?: String;
  hash_starts_with?: String;
  hash_not_starts_with?: String;
  hash_ends_with?: String;
  hash_not_ends_with?: String;
  AND?: UserActivationHashWhereInput[] | UserActivationHashWhereInput;
  OR?: UserActivationHashWhereInput[] | UserActivationHashWhereInput;
  NOT?: UserActivationHashWhereInput[] | UserActivationHashWhereInput;
}

export interface CompanyUpdateOneRequiredInput {
  create?: CompanyCreateInput;
  update?: CompanyUpdateDataInput;
  upsert?: CompanyUpsertNestedInput;
  connect?: CompanyWhereUniqueInput;
}

export interface CompanyWhereInput {
  siret?: String;
  siret_not?: String;
  siret_in?: String[] | String;
  siret_not_in?: String[] | String;
  siret_lt?: String;
  siret_lte?: String;
  siret_gt?: String;
  siret_gte?: String;
  siret_contains?: String;
  siret_not_contains?: String;
  siret_starts_with?: String;
  siret_not_starts_with?: String;
  siret_ends_with?: String;
  siret_not_ends_with?: String;
  AND?: CompanyWhereInput[] | CompanyWhereInput;
  OR?: CompanyWhereInput[] | CompanyWhereInput;
  NOT?: CompanyWhereInput[] | CompanyWhereInput;
}

export interface UserUpdateManyMutationInput {
  isActive?: Boolean;
  email?: String;
  password?: String;
  name?: String;
  phone?: String;
  userType?: Json;
}

export interface UserCreateOneInput {
  create?: UserCreateInput;
  connect?: UserWhereUniqueInput;
}

export interface CompanyUpsertNestedInput {
  update: CompanyUpdateDataInput;
  create: CompanyCreateInput;
}

export interface UserActivationHashSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserActivationHashWhereInput;
  AND?:
    | UserActivationHashSubscriptionWhereInput[]
    | UserActivationHashSubscriptionWhereInput;
  OR?:
    | UserActivationHashSubscriptionWhereInput[]
    | UserActivationHashSubscriptionWhereInput;
  NOT?:
    | UserActivationHashSubscriptionWhereInput[]
    | UserActivationHashSubscriptionWhereInput;
}

export interface CompanyCreateInput {
  siret: String;
}

export interface CompanyUpdateManyMutationInput {
  siret?: String;
}

export interface FormCreateInput {
  readableId: String;
  isDeleted?: Boolean;
  owner: UserCreateOneInput;
  status?: String;
  sentAt?: DateTimeInput;
  sentBy?: String;
  isAccepted?: Boolean;
  receivedBy?: String;
  receivedAt?: DateTimeInput;
  quantityReceived?: Float;
  processingOperationDone?: String;
  emitterType?: EmitterType;
  emitterPickupSite?: String;
  emitterCompanyName?: String;
  emitterCompanySiret?: String;
  emitterCompanyAddress?: String;
  emitterCompanyContact?: String;
  emitterCompanyPhone?: String;
  emitterCompanyMail?: String;
  recipientCap?: String;
  recipientProcessingOperation?: String;
  recipientCompanyName?: String;
  recipientCompanySiret?: String;
  recipientCompanyAddress?: String;
  recipientCompanyContact?: String;
  recipientCompanyPhone?: String;
  recipientCompanyMail?: String;
  transporterCompanyName?: String;
  transporterCompanySiret?: String;
  transporterCompanyAddress?: String;
  transporterCompanyContact?: String;
  transporterCompanyPhone?: String;
  transporterCompanyMail?: String;
  transporterReceipt?: String;
  transporterDepartment?: String;
  transporterValidityLimit?: DateTimeInput;
  transporterContact?: String;
  transporterNumberPlate?: String;
  wasteDetailsCode?: String;
  wasteDetailsName?: String;
  wasteDetailsOnuCode?: String;
  wasteDetailsPackagings?: Json;
  wasteDetailsOtherPackaging?: String;
  wasteDetailsNumberOfPackages?: Int;
  wasteDetailsQuantity?: Float;
  wasteDetailsQuantityType?: QuantityType;
}

export interface CompanyUpdateDataInput {
  siret?: String;
}

export interface CompanySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CompanyWhereInput;
  AND?: CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput;
  OR?: CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput;
  NOT?: CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput;
}

export interface FormUpdateManyMutationInput {
  readableId?: String;
  isDeleted?: Boolean;
  status?: String;
  sentAt?: DateTimeInput;
  sentBy?: String;
  isAccepted?: Boolean;
  receivedBy?: String;
  receivedAt?: DateTimeInput;
  quantityReceived?: Float;
  processingOperationDone?: String;
  emitterType?: EmitterType;
  emitterPickupSite?: String;
  emitterCompanyName?: String;
  emitterCompanySiret?: String;
  emitterCompanyAddress?: String;
  emitterCompanyContact?: String;
  emitterCompanyPhone?: String;
  emitterCompanyMail?: String;
  recipientCap?: String;
  recipientProcessingOperation?: String;
  recipientCompanyName?: String;
  recipientCompanySiret?: String;
  recipientCompanyAddress?: String;
  recipientCompanyContact?: String;
  recipientCompanyPhone?: String;
  recipientCompanyMail?: String;
  transporterCompanyName?: String;
  transporterCompanySiret?: String;
  transporterCompanyAddress?: String;
  transporterCompanyContact?: String;
  transporterCompanyPhone?: String;
  transporterCompanyMail?: String;
  transporterReceipt?: String;
  transporterDepartment?: String;
  transporterValidityLimit?: DateTimeInput;
  transporterContact?: String;
  transporterNumberPlate?: String;
  wasteDetailsCode?: String;
  wasteDetailsName?: String;
  wasteDetailsOnuCode?: String;
  wasteDetailsPackagings?: Json;
  wasteDetailsOtherPackaging?: String;
  wasteDetailsNumberOfPackages?: Int;
  wasteDetailsQuantity?: Float;
  wasteDetailsQuantityType?: QuantityType;
}

export type FormWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  readableId?: String;
}>;

export interface NodeNode {
  id: ID_Output;
}

export interface AggregateUserActivationHash {
  count: Int;
}

export interface AggregateUserActivationHashPromise
  extends Promise<AggregateUserActivationHash>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserActivationHashSubscription
  extends Promise<AsyncIterator<AggregateUserActivationHash>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Form {
  id: ID_Output;
  readableId: String;
  isDeleted?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  status?: String;
  sentAt?: DateTimeOutput;
  sentBy?: String;
  isAccepted?: Boolean;
  receivedBy?: String;
  receivedAt?: DateTimeOutput;
  quantityReceived?: Float;
  processingOperationDone?: String;
  emitterType?: EmitterType;
  emitterPickupSite?: String;
  emitterCompanyName?: String;
  emitterCompanySiret?: String;
  emitterCompanyAddress?: String;
  emitterCompanyContact?: String;
  emitterCompanyPhone?: String;
  emitterCompanyMail?: String;
  recipientCap?: String;
  recipientProcessingOperation?: String;
  recipientCompanyName?: String;
  recipientCompanySiret?: String;
  recipientCompanyAddress?: String;
  recipientCompanyContact?: String;
  recipientCompanyPhone?: String;
  recipientCompanyMail?: String;
  transporterCompanyName?: String;
  transporterCompanySiret?: String;
  transporterCompanyAddress?: String;
  transporterCompanyContact?: String;
  transporterCompanyPhone?: String;
  transporterCompanyMail?: String;
  transporterReceipt?: String;
  transporterDepartment?: String;
  transporterValidityLimit?: DateTimeOutput;
  transporterContact?: String;
  transporterNumberPlate?: String;
  wasteDetailsCode?: String;
  wasteDetailsName?: String;
  wasteDetailsOnuCode?: String;
  wasteDetailsPackagings?: Json;
  wasteDetailsOtherPackaging?: String;
  wasteDetailsNumberOfPackages?: Int;
  wasteDetailsQuantity?: Float;
  wasteDetailsQuantityType?: QuantityType;
}

export interface FormPromise extends Promise<Form>, Fragmentable {
  id: () => Promise<ID_Output>;
  readableId: () => Promise<String>;
  isDeleted: () => Promise<Boolean>;
  owner: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  status: () => Promise<String>;
  sentAt: () => Promise<DateTimeOutput>;
  sentBy: () => Promise<String>;
  isAccepted: () => Promise<Boolean>;
  receivedBy: () => Promise<String>;
  receivedAt: () => Promise<DateTimeOutput>;
  quantityReceived: () => Promise<Float>;
  processingOperationDone: () => Promise<String>;
  emitterType: () => Promise<EmitterType>;
  emitterPickupSite: () => Promise<String>;
  emitterCompanyName: () => Promise<String>;
  emitterCompanySiret: () => Promise<String>;
  emitterCompanyAddress: () => Promise<String>;
  emitterCompanyContact: () => Promise<String>;
  emitterCompanyPhone: () => Promise<String>;
  emitterCompanyMail: () => Promise<String>;
  recipientCap: () => Promise<String>;
  recipientProcessingOperation: () => Promise<String>;
  recipientCompanyName: () => Promise<String>;
  recipientCompanySiret: () => Promise<String>;
  recipientCompanyAddress: () => Promise<String>;
  recipientCompanyContact: () => Promise<String>;
  recipientCompanyPhone: () => Promise<String>;
  recipientCompanyMail: () => Promise<String>;
  transporterCompanyName: () => Promise<String>;
  transporterCompanySiret: () => Promise<String>;
  transporterCompanyAddress: () => Promise<String>;
  transporterCompanyContact: () => Promise<String>;
  transporterCompanyPhone: () => Promise<String>;
  transporterCompanyMail: () => Promise<String>;
  transporterReceipt: () => Promise<String>;
  transporterDepartment: () => Promise<String>;
  transporterValidityLimit: () => Promise<DateTimeOutput>;
  transporterContact: () => Promise<String>;
  transporterNumberPlate: () => Promise<String>;
  wasteDetailsCode: () => Promise<String>;
  wasteDetailsName: () => Promise<String>;
  wasteDetailsOnuCode: () => Promise<String>;
  wasteDetailsPackagings: () => Promise<Json>;
  wasteDetailsOtherPackaging: () => Promise<String>;
  wasteDetailsNumberOfPackages: () => Promise<Int>;
  wasteDetailsQuantity: () => Promise<Float>;
  wasteDetailsQuantityType: () => Promise<QuantityType>;
}

export interface FormSubscription
  extends Promise<AsyncIterator<Form>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  readableId: () => Promise<AsyncIterator<String>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  owner: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  status: () => Promise<AsyncIterator<String>>;
  sentAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sentBy: () => Promise<AsyncIterator<String>>;
  isAccepted: () => Promise<AsyncIterator<Boolean>>;
  receivedBy: () => Promise<AsyncIterator<String>>;
  receivedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  quantityReceived: () => Promise<AsyncIterator<Float>>;
  processingOperationDone: () => Promise<AsyncIterator<String>>;
  emitterType: () => Promise<AsyncIterator<EmitterType>>;
  emitterPickupSite: () => Promise<AsyncIterator<String>>;
  emitterCompanyName: () => Promise<AsyncIterator<String>>;
  emitterCompanySiret: () => Promise<AsyncIterator<String>>;
  emitterCompanyAddress: () => Promise<AsyncIterator<String>>;
  emitterCompanyContact: () => Promise<AsyncIterator<String>>;
  emitterCompanyPhone: () => Promise<AsyncIterator<String>>;
  emitterCompanyMail: () => Promise<AsyncIterator<String>>;
  recipientCap: () => Promise<AsyncIterator<String>>;
  recipientProcessingOperation: () => Promise<AsyncIterator<String>>;
  recipientCompanyName: () => Promise<AsyncIterator<String>>;
  recipientCompanySiret: () => Promise<AsyncIterator<String>>;
  recipientCompanyAddress: () => Promise<AsyncIterator<String>>;
  recipientCompanyContact: () => Promise<AsyncIterator<String>>;
  recipientCompanyPhone: () => Promise<AsyncIterator<String>>;
  recipientCompanyMail: () => Promise<AsyncIterator<String>>;
  transporterCompanyName: () => Promise<AsyncIterator<String>>;
  transporterCompanySiret: () => Promise<AsyncIterator<String>>;
  transporterCompanyAddress: () => Promise<AsyncIterator<String>>;
  transporterCompanyContact: () => Promise<AsyncIterator<String>>;
  transporterCompanyPhone: () => Promise<AsyncIterator<String>>;
  transporterCompanyMail: () => Promise<AsyncIterator<String>>;
  transporterReceipt: () => Promise<AsyncIterator<String>>;
  transporterDepartment: () => Promise<AsyncIterator<String>>;
  transporterValidityLimit: () => Promise<AsyncIterator<DateTimeOutput>>;
  transporterContact: () => Promise<AsyncIterator<String>>;
  transporterNumberPlate: () => Promise<AsyncIterator<String>>;
  wasteDetailsCode: () => Promise<AsyncIterator<String>>;
  wasteDetailsName: () => Promise<AsyncIterator<String>>;
  wasteDetailsOnuCode: () => Promise<AsyncIterator<String>>;
  wasteDetailsPackagings: () => Promise<AsyncIterator<Json>>;
  wasteDetailsOtherPackaging: () => Promise<AsyncIterator<String>>;
  wasteDetailsNumberOfPackages: () => Promise<AsyncIterator<Int>>;
  wasteDetailsQuantity: () => Promise<AsyncIterator<Float>>;
  wasteDetailsQuantityType: () => Promise<AsyncIterator<QuantityType>>;
}

export interface UserActivationHashPreviousValues {
  id: ID_Output;
  hash: String;
}

export interface UserActivationHashPreviousValuesPromise
  extends Promise<UserActivationHashPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  hash: () => Promise<String>;
}

export interface UserActivationHashPreviousValuesSubscription
  extends Promise<AsyncIterator<UserActivationHashPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  hash: () => Promise<AsyncIterator<String>>;
}

export interface User {
  id: ID_Output;
  isActive?: Boolean;
  email: String;
  password: String;
  name?: String;
  phone?: String;
  userType?: Json;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  isActive: () => Promise<Boolean>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  name: () => Promise<String>;
  phone: () => Promise<String>;
  company: <T = CompanyPromise>() => T;
  userType: () => Promise<Json>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  isActive: () => Promise<AsyncIterator<Boolean>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  company: <T = CompanySubscription>() => T;
  userType: () => Promise<AsyncIterator<Json>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FormPreviousValues {
  id: ID_Output;
  readableId: String;
  isDeleted?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  status?: String;
  sentAt?: DateTimeOutput;
  sentBy?: String;
  isAccepted?: Boolean;
  receivedBy?: String;
  receivedAt?: DateTimeOutput;
  quantityReceived?: Float;
  processingOperationDone?: String;
  emitterType?: EmitterType;
  emitterPickupSite?: String;
  emitterCompanyName?: String;
  emitterCompanySiret?: String;
  emitterCompanyAddress?: String;
  emitterCompanyContact?: String;
  emitterCompanyPhone?: String;
  emitterCompanyMail?: String;
  recipientCap?: String;
  recipientProcessingOperation?: String;
  recipientCompanyName?: String;
  recipientCompanySiret?: String;
  recipientCompanyAddress?: String;
  recipientCompanyContact?: String;
  recipientCompanyPhone?: String;
  recipientCompanyMail?: String;
  transporterCompanyName?: String;
  transporterCompanySiret?: String;
  transporterCompanyAddress?: String;
  transporterCompanyContact?: String;
  transporterCompanyPhone?: String;
  transporterCompanyMail?: String;
  transporterReceipt?: String;
  transporterDepartment?: String;
  transporterValidityLimit?: DateTimeOutput;
  transporterContact?: String;
  transporterNumberPlate?: String;
  wasteDetailsCode?: String;
  wasteDetailsName?: String;
  wasteDetailsOnuCode?: String;
  wasteDetailsPackagings?: Json;
  wasteDetailsOtherPackaging?: String;
  wasteDetailsNumberOfPackages?: Int;
  wasteDetailsQuantity?: Float;
  wasteDetailsQuantityType?: QuantityType;
}

export interface FormPreviousValuesPromise
  extends Promise<FormPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  readableId: () => Promise<String>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  status: () => Promise<String>;
  sentAt: () => Promise<DateTimeOutput>;
  sentBy: () => Promise<String>;
  isAccepted: () => Promise<Boolean>;
  receivedBy: () => Promise<String>;
  receivedAt: () => Promise<DateTimeOutput>;
  quantityReceived: () => Promise<Float>;
  processingOperationDone: () => Promise<String>;
  emitterType: () => Promise<EmitterType>;
  emitterPickupSite: () => Promise<String>;
  emitterCompanyName: () => Promise<String>;
  emitterCompanySiret: () => Promise<String>;
  emitterCompanyAddress: () => Promise<String>;
  emitterCompanyContact: () => Promise<String>;
  emitterCompanyPhone: () => Promise<String>;
  emitterCompanyMail: () => Promise<String>;
  recipientCap: () => Promise<String>;
  recipientProcessingOperation: () => Promise<String>;
  recipientCompanyName: () => Promise<String>;
  recipientCompanySiret: () => Promise<String>;
  recipientCompanyAddress: () => Promise<String>;
  recipientCompanyContact: () => Promise<String>;
  recipientCompanyPhone: () => Promise<String>;
  recipientCompanyMail: () => Promise<String>;
  transporterCompanyName: () => Promise<String>;
  transporterCompanySiret: () => Promise<String>;
  transporterCompanyAddress: () => Promise<String>;
  transporterCompanyContact: () => Promise<String>;
  transporterCompanyPhone: () => Promise<String>;
  transporterCompanyMail: () => Promise<String>;
  transporterReceipt: () => Promise<String>;
  transporterDepartment: () => Promise<String>;
  transporterValidityLimit: () => Promise<DateTimeOutput>;
  transporterContact: () => Promise<String>;
  transporterNumberPlate: () => Promise<String>;
  wasteDetailsCode: () => Promise<String>;
  wasteDetailsName: () => Promise<String>;
  wasteDetailsOnuCode: () => Promise<String>;
  wasteDetailsPackagings: () => Promise<Json>;
  wasteDetailsOtherPackaging: () => Promise<String>;
  wasteDetailsNumberOfPackages: () => Promise<Int>;
  wasteDetailsQuantity: () => Promise<Float>;
  wasteDetailsQuantityType: () => Promise<QuantityType>;
}

export interface FormPreviousValuesSubscription
  extends Promise<AsyncIterator<FormPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  readableId: () => Promise<AsyncIterator<String>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  status: () => Promise<AsyncIterator<String>>;
  sentAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sentBy: () => Promise<AsyncIterator<String>>;
  isAccepted: () => Promise<AsyncIterator<Boolean>>;
  receivedBy: () => Promise<AsyncIterator<String>>;
  receivedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  quantityReceived: () => Promise<AsyncIterator<Float>>;
  processingOperationDone: () => Promise<AsyncIterator<String>>;
  emitterType: () => Promise<AsyncIterator<EmitterType>>;
  emitterPickupSite: () => Promise<AsyncIterator<String>>;
  emitterCompanyName: () => Promise<AsyncIterator<String>>;
  emitterCompanySiret: () => Promise<AsyncIterator<String>>;
  emitterCompanyAddress: () => Promise<AsyncIterator<String>>;
  emitterCompanyContact: () => Promise<AsyncIterator<String>>;
  emitterCompanyPhone: () => Promise<AsyncIterator<String>>;
  emitterCompanyMail: () => Promise<AsyncIterator<String>>;
  recipientCap: () => Promise<AsyncIterator<String>>;
  recipientProcessingOperation: () => Promise<AsyncIterator<String>>;
  recipientCompanyName: () => Promise<AsyncIterator<String>>;
  recipientCompanySiret: () => Promise<AsyncIterator<String>>;
  recipientCompanyAddress: () => Promise<AsyncIterator<String>>;
  recipientCompanyContact: () => Promise<AsyncIterator<String>>;
  recipientCompanyPhone: () => Promise<AsyncIterator<String>>;
  recipientCompanyMail: () => Promise<AsyncIterator<String>>;
  transporterCompanyName: () => Promise<AsyncIterator<String>>;
  transporterCompanySiret: () => Promise<AsyncIterator<String>>;
  transporterCompanyAddress: () => Promise<AsyncIterator<String>>;
  transporterCompanyContact: () => Promise<AsyncIterator<String>>;
  transporterCompanyPhone: () => Promise<AsyncIterator<String>>;
  transporterCompanyMail: () => Promise<AsyncIterator<String>>;
  transporterReceipt: () => Promise<AsyncIterator<String>>;
  transporterDepartment: () => Promise<AsyncIterator<String>>;
  transporterValidityLimit: () => Promise<AsyncIterator<DateTimeOutput>>;
  transporterContact: () => Promise<AsyncIterator<String>>;
  transporterNumberPlate: () => Promise<AsyncIterator<String>>;
  wasteDetailsCode: () => Promise<AsyncIterator<String>>;
  wasteDetailsName: () => Promise<AsyncIterator<String>>;
  wasteDetailsOnuCode: () => Promise<AsyncIterator<String>>;
  wasteDetailsPackagings: () => Promise<AsyncIterator<Json>>;
  wasteDetailsOtherPackaging: () => Promise<AsyncIterator<String>>;
  wasteDetailsNumberOfPackages: () => Promise<AsyncIterator<Int>>;
  wasteDetailsQuantity: () => Promise<AsyncIterator<Float>>;
  wasteDetailsQuantityType: () => Promise<AsyncIterator<QuantityType>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface UserActivationHash {
  id: ID_Output;
  hash: String;
}

export interface UserActivationHashPromise
  extends Promise<UserActivationHash>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  hash: () => Promise<String>;
}

export interface UserActivationHashSubscription
  extends Promise<AsyncIterator<UserActivationHash>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  hash: () => Promise<AsyncIterator<String>>;
}

export interface UserActivationHashEdge {
  cursor: String;
}

export interface UserActivationHashEdgePromise
  extends Promise<UserActivationHashEdge>,
    Fragmentable {
  node: <T = UserActivationHashPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserActivationHashEdgeSubscription
  extends Promise<AsyncIterator<UserActivationHashEdge>>,
    Fragmentable {
  node: <T = UserActivationHashSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserEdge {
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCompany {
  count: Int;
}

export interface AggregateCompanyPromise
  extends Promise<AggregateCompany>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCompanySubscription
  extends Promise<AsyncIterator<AggregateCompany>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateForm {
  count: Int;
}

export interface AggregateFormPromise
  extends Promise<AggregateForm>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFormSubscription
  extends Promise<AsyncIterator<AggregateForm>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CompanyEdge {
  cursor: String;
}

export interface CompanyEdgePromise extends Promise<CompanyEdge>, Fragmentable {
  node: <T = CompanyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CompanyEdgeSubscription
  extends Promise<AsyncIterator<CompanyEdge>>,
    Fragmentable {
  node: <T = CompanySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface FormConnection {}

export interface FormConnectionPromise
  extends Promise<FormConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FormEdge>>() => T;
  aggregate: <T = AggregateFormPromise>() => T;
}

export interface FormConnectionSubscription
  extends Promise<AsyncIterator<FormConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FormEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFormSubscription>() => T;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface Company {
  siret: String;
}

export interface CompanyPromise extends Promise<Company>, Fragmentable {
  siret: () => Promise<String>;
}

export interface CompanySubscription
  extends Promise<AsyncIterator<Company>>,
    Fragmentable {
  siret: () => Promise<AsyncIterator<String>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface UserActivationHashConnection {}

export interface UserActivationHashConnectionPromise
  extends Promise<UserActivationHashConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserActivationHashEdge>>() => T;
  aggregate: <T = AggregateUserActivationHashPromise>() => T;
}

export interface UserActivationHashConnectionSubscription
  extends Promise<AsyncIterator<UserActivationHashConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<UserActivationHashEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateUserActivationHashSubscription>() => T;
}

export interface FormSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface FormSubscriptionPayloadPromise
  extends Promise<FormSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FormPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FormPreviousValuesPromise>() => T;
}

export interface FormSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FormSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FormSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FormPreviousValuesSubscription>() => T;
}

export interface CompanyConnection {}

export interface CompanyConnectionPromise
  extends Promise<CompanyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CompanyEdge>>() => T;
  aggregate: <T = AggregateCompanyPromise>() => T;
}

export interface CompanyConnectionSubscription
  extends Promise<AsyncIterator<CompanyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CompanyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCompanySubscription>() => T;
}

export interface CompanyPreviousValues {
  siret: String;
}

export interface CompanyPreviousValuesPromise
  extends Promise<CompanyPreviousValues>,
    Fragmentable {
  siret: () => Promise<String>;
}

export interface CompanyPreviousValuesSubscription
  extends Promise<AsyncIterator<CompanyPreviousValues>>,
    Fragmentable {
  siret: () => Promise<AsyncIterator<String>>;
}

export interface CompanySubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface CompanySubscriptionPayloadPromise
  extends Promise<CompanySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CompanyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CompanyPreviousValuesPromise>() => T;
}

export interface CompanySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CompanySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CompanySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CompanyPreviousValuesSubscription>() => T;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserPreviousValues {
  id: ID_Output;
  isActive?: Boolean;
  email: String;
  password: String;
  name?: String;
  phone?: String;
  userType?: Json;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  isActive: () => Promise<Boolean>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  name: () => Promise<String>;
  phone: () => Promise<String>;
  userType: () => Promise<Json>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  isActive: () => Promise<AsyncIterator<Boolean>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  userType: () => Promise<AsyncIterator<Json>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserActivationHashSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface UserActivationHashSubscriptionPayloadPromise
  extends Promise<UserActivationHashSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserActivationHashPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserActivationHashPreviousValuesPromise>() => T;
}

export interface UserActivationHashSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserActivationHashSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserActivationHashSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserActivationHashPreviousValuesSubscription>() => T;
}

export interface FormEdge {
  cursor: String;
}

export interface FormEdgePromise extends Promise<FormEdge>, Fragmentable {
  node: <T = FormPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FormEdgeSubscription
  extends Promise<AsyncIterator<FormEdge>>,
    Fragmentable {
  node: <T = FormSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserConnection {}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

export type Long = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

export type Json = any;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/**
 * Model Metadata
 */

export const models = [
  {
    name: "Company",
    embedded: false
  },
  {
    name: "EmitterType",
    embedded: false
  },
  {
    name: "Form",
    embedded: false
  },
  {
    name: "QuantityType",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "UserActivationHash",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `http://prisma:4466`,
  secret: `trackdechets-prisma`
});
export const prisma = new Prisma();
